From 55eca38889c08fa2aebdcf673c2e8922ba226716 Mon Sep 17 00:00:00 2001
From: Raw Pong Ghmoa <58883403+q9f@users.noreply.github.com>
Date: Fri, 11 Sep 2020 19:51:48 +0200
Subject: [PATCH] ECIP 1099: Add block numbers and move to Last Call

---
 _specs/ecip-1099.md | 19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/_specs/ecip-1099.md b/_specs/ecip-1099.md
index aa60c03a7..60bedc272 100644
--- a/_specs/ecip-1099.md
+++ b/_specs/ecip-1099.md
@@ -2,7 +2,8 @@
 lang: en
 ecip: 1099
 title: Calibrate Epoch Duration
-status: Draft
+status: Last Call
+review-period-end: 2020-10-02
 type: Standards Track
 category: Core
 discussions-to: https://github.com/ethereumclassic/ECIPs/issues/368
@@ -12,21 +13,31 @@ replaces: 1043
 license: Apache-2
 ---
 
-### Abstract
+### Abstract ###
 
 The purpose of this ECIP is to calibrate the epoch length used in DAG calculations.
 
 ### Motivation ###
+
 The original intent of the DAG was to provide ASIC resistance to the mining protocol in order to prevent centralization of mining distributions and thereby provide for an objectively fair distribution of tokens. As evident by ASICs being developed that are capable of matching current GPU miners while being more energy efficient, the DAG has succeeded in leveling the playing field between GPU incumbents and ASIC challengers, avoiding ASIC takeover and domination, and leading to a competitive and large mining ecosystem. However the original parameters are proving too aggressive, resulting in obsoleting support for GPUs still in wide use today by miners.
 
 Calibrating these parameters to better reflect todays hardware markets and mining ecosystem will bring the DAG growth back in sync with commonly used GPUs. Allowing the DAG system to continue to serve it's purpose far into the future.
 
+### Parameters ###
+
+Ethash transitions to a modified Dagger Hashimoto algorithm, referred to hereby as _Etchash_, on block `ETCHASH_FORK_BLOCK`:
+
+* For the Ethereum Classic main network: `ETCHASH_FORK_BLOCK := 11_460_000` (Epoch 382)
+* For the Mordor Classic test network: `ETCHASH_FORK_BLOCK := 2_340_000` (Epoch 78)
+
 ### Specification ###
 
+On `ETCHASH_FORK_BLOCK`, activate the following Etchash logic:
+
 ```
 const oldEpochLength = 30000
 const newEpochLength = 60000
-const activationBlock = n
+const activationBlock = ETCHASH_FORK_BLOCK
 
 // calcEpochLength returns the epoch length for a given block number.
 func calcEpochLength(blockNum uint64) uint64 {
@@ -58,7 +69,7 @@ func seedHash(block uint64) []byte {
   return seed
 }
 ```
-The oldEpochLength (30000) changes to newEpochLength (60000) at a given activationBlock (hardfork required).
+The oldEpochLength (30000) changes to newEpochLength (60000) at a given `ETCHASH_FORK_BLOCK` (hardfork required).
 
 This will result in the epoch (blockNumber/[old/new]EpochLength) halving upon activation. As the DAG cache and dataset sizes are calculated from epoch, the growth in which they have experienced too will half upon activation. DAG caches and dataset will then continue to grow as intended, however at half of the pre-activation rate. To avoid re-use of seeds oldEpochLength will continue to be used within the seedHash function.
 
