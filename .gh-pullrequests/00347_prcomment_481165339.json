{
    "url": "https://api.github.com/repos/ethereumclassic/ECIPs/pulls/comments/481165339",
    "pull_request_review_id": 479778499,
    "id": 481165339,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE2NTMzOQ==",
    "diff_hunk": "@@ -0,0 +1,282 @@\n+---\n+ecip: <ECIP number>\n+title: 51% Attack Resistance \n+lang: en\n+author: Dimitris Karakostas, Radek Tkaczyk, Romain Pellerin, Brian McKenna\n+discussions-to: https://github.com/ethereumclassic/ECIPs/issues/348 | https://github.com/input-output-hk/ECIPs/issues/1\n+status: Draft\n+type: Standards Track\n+category: Core\n+created: 2020-08-26\n+---\n+\n+### Abstract\n+\n+This document outlines a proposal for the implementation of a system to provide 51% attack resistance on the Ethereum Classic blockchain. It describes the high-level structure and general properties of such a system. IOHK has already researched and implemented the checkpointing protection on ETC, and has detailed specifications for each part of the system, as well as reference implementation, that can be found in [this repository](https://github.com/input-output-hk/checkpointing_code_plus_ecip).\n+\n+### Motivation\n+\n+Distributed ledgers based on the Proof-of-Work (PoW) paradigm are typically most vulnerable when mining participation is low. During these periods an attacker can mount devastating attacks, such as double spending or censorship of transactions [^CHECK]. We have seen recently that this is particularly relevant to ETC, as witnessed by the two attacks that took place in August 2020.\n+\n+Checkpointing is proposed as a mechanism to mitigate such 51% attacks. The core idea is to employ an external set of parties that securely run an assisting service which guarantees the ledger's properties and can be relied upon at times when the invested hashing power is low. Once hashing power reaches a level where an attack is no longer financially viable, the system can be discontinued.\n+\n+The future viability of ETC in its current, unsecured state is now in question. Implementing a fully tested Checkpointing solution, running the Ouroboros-BFT (OBFT) consensus protocol, would provide high assurance, with low performance requirements. It would also boost confidence in the network and provide the much needed stability required to take ETC to a level where 51% attacks are no longer feasible.\n+\n+### Specification\n+\n+The checkpointing authority monitors the growth of the chain and periodically issues checkpoints, which are points at which validations occur. As soon as it observes the first valid chain, which extends the latest checkpoint by `ùëò` blocks (for some constant value `ùëò`), the authority signs this chain‚Äôs last block and broadcasts this signature, thus producing a new checkpoint.\n+\n+From the user perspective, chain selection is augmented by enforcing a rule where a chain is valid only if it extends the latest checkpoint. In particular, when selecting a chain, honest use applies as follows:\n+\n+- first verifies that it contains the latest checkpoint; and\n+- then applies the longest-chain rule to all validly checkpointed candidates.\n+\n+Even an adversary controlling a majority of the mining power cannot revert the block history secured by the latest checkpoint, as an honest user will (eventually) reject any chain that does not extend this checkpoint.\n+\n+The checkpointing authority is distributed among a number `ùëõ` of nodes. These nodes run an internal Byzantine fault tolerant (BFT) consensus protocol, Ouroboros BFT [^OBFT], to coordinate the issuing of checkpoints.\n+\n+The checkpointing nodes use a multi-signature scheme to produce each checkpoint. A ùë°-out-of-ùëõ multi-signature scheme allows a set of ùëõ parties to collectively sign a message under the necessary condition that at least `ùë°` of the parties collaborate in order to sign this message. The checkpointing nodes issue their chosen checkpoints by creating respective multi-signature2s using their keys. Choosing ``ùë° > ùëõ ‚àí ùë°`` implies that correct (agreed-upon) checkpoints will be continuously produced, while the forgery of checkpoints is impossible assuming that a minority of the checkpointing nodes is corrupted.\n+\n+#### Checkpointing Service\n+\n+The federation needs to agree upon the block to be checkpointed. The proposed solution consist of two components:\n+\n+- a dedicated ETC node that will be used by the federation to monitor and retreive data.\n+- a checkpointing service server (the server) which allows federation nodes to reach an agreement.\n+\n+The server is based on Ouroboros BFT [^OBFT]. Ourobotos BFT is a blockchain-based Byzantine Fault Tolerant protocol, i.e. it‚Äôs resilient to `t < n / 3` faults, that aims to be simple without compromising security soundness. \n+\n+Simplicity is achieved by the fact participants just need to do two things: extend their blockchain and generate the next block, if they are eligible.\n+\n+The service should periodically execute the following process:\n+\n+1. Fetch the latest block candidate for checkpointing using `checkpointing_getLatestBlock` RPC call. This RPC method returns just the number and hash of the latest matching block, for which `block_number % checkpointing_interval == 0`\n+2. Cast a vote with a signature for this block. The vote is a transaction broadcasted in the OBFT network\n+3. Upon reaching consensus in the OBFT chain (a majority of votes for a given ETC block), a checkpoint with all matching signatures is sent to the associated ETC nodes, from where it is broadcasted to the entire network.\n+\n+#### Checkpointing Network Definition\n+\n+The method for selecting the checkpointing committee is a key element of this proposal and must be carefully analyzed and agreed by the ETC community members who have considered the governance implications. In fact, the original PoW consensus is augmented by a layer of security offered by a checkpointing network. This network can be either secured by a federation of ETC entities, by the dynamic selection of a random committee of ETC miners or by implementing a timestamping protocol on an external chain (BTC).\n+\n+These three options and how they can be implemented are outlined as part  of this proposal:\n+\n+##### Option 1: Trusted network of federated ETC entities\n+\n+In this federated option, the checkpointing network is operated and secured by a committee of n members selected by the ETC community. This committee can be either:\n+\n+- founded by `k` entities and extended by a majority vote, `k < n`;\n+- extended to miners and/or developers and/or stakeholders;\n+- elected for a period of time `t`;\n+\n+We envisage that a multitude of selection criteria could be used to form the committee, but we advise the community to keep this mechanism as lean as possible in a _first implementation by defining a fixed group of federation members_. \n+\n+We understand that the aforementioned alternative might not be optimally flexible, so we are proposing an optional improvement that will allow checkpointing to potentially rotate the checkpointing federation. The specific implementation of this federated option will be provided as a smart contract that adheres to the following election mechanism:\n+\n+- `p` the duration of a voting epoch \n+- `a` voting epoch is comprised of three periods; pre-voting, voting, and tally, each lasting `p/3`\n+- pre-voting period starts;\n+- `C` candidates register with their respective public key;\n+- at the end of the pre-voting step if `C < n` the vote fails and go to 1;\n+- else the voting period starts;\n+- each stakeholder votes with his/her ETC stake for the candidate(s) of his/her choice, and stake is locked until the vote ends;\n+- voting period ends;\n+- tally period starts and calculates the list of entities which gathered the most stake (in case of equivalent stake lexical order of public key prevails), and will form the committee for a designated period of time;\n+- tally ends, list is confirmed;\n+- when `t - p` expires go to 1.\n+\n+Optionally, we can provide a privacy-enabled voting mechanism to ensure that votes will remain anonymous. Depending on the complexity this might be delivered as a second-layer solution. \n+\n+We suggest the following configuration: `p=30 (days)`, `n=100`  and  `t=180 (days)`. \n+\n+This list can be publicly accessed through a getter smart-contract.\n+\n+This method can then be called by the nodes that participate in the checkpointing network, and only the nodes listed can issue checkpoints themselves.\n+\n+- Pros:\n+    - Community-driven and on-chain selection of com mittee\n+    - Reliability of the n participants\n+\n+- Cons:\n+    - A very wealthy attacker can register multiple public keys and vote for himself to obtain a majority of checkpoint signatures \n+    - This is an example of how one could implement a voting scheme, however this scheme starts to resemble Proof of Stake and it may be worthwhile considering hybrid consensus if this scheme is deemed favourable by the community\n+\n+\n+##### Option 2: Dynamic network of ETC miners\n+\n+In this dynamic and random selection option, the checkpointing network is operated and secured by a committee of k miners who are randomly selected at every epoch through the blockchain data structure and history. The parameters for this random selection can be either :\n+- based on the lexical distance of the miner‚Äôs public key with the last block hash;\n+- within a window of time determining a subset of miners;\n+- within a set of NiPoPoWs [^NIPOPOW] graphs;\n+\n+We envisage that a multitude of randomized selection algorithms could be used, but we advise the community to select the solution that offers the best resistance to attacks.\n+\n+The specific implementation of this dynamic and random selection option will be provided as a consensus algorithm used in the checkpointing blockchain that actively monitors the ETC blockchain. The following is a draft proposal for the committee selection algorithm that we consider offers  sufficient protection against long range attacks:\n+- `e` an epoch of a duration t in which a new list of at least `n` miners is determined;\n+- `p` the maximum processing time for this algorithm;\n+- `w` a sliding window of `k blocks` from the latest block of the latest epoch `window + window_min` (or `last block - window_min` at initialization), `k` calculated based on the difficulty  and  `k > window_min`;\n+- calculate `npp(k)` the subset of `k` latest NiPoPow graphs;\n+- calculate `l(npp(k))`the list of miners‚Äô public keys that have contributed to mine the blocks contained by `npp(k)`removing duplicates (set);\n+- if `length(l(npp(k))) < n` go to 2.;\n+- else the list is determined \n+- when `t - p` expires go to 1.\n+\n+- Pros\n+    - Checkpointing network is secured by miners\n+    - On-chain selection of committee\n+    - Decreased risk of collusion within the committee\n+- Cons\n+    - Sensitive to long range attacks \n+    - Draft solution and the secure algorithm, or equivalent, needs to be formalised\n+    - It may not be possible to prove a satisfactory level of security with this scheme, also to make such a scheme secure will likely increase implementation complexity\n+\n+##### Option 3: Auxiliary Security from an External Blockchain",
    "path": "_specs/51_attack_resistance.md",
    "position": null,
    "original_position": 132,
    "commit_id": "76e582838ec48b3248e4264a562c0e53cee6e95b",
    "original_commit_id": "51cd72ea08557a38876e80fbc7471967a8a27a42",
    "user": {
      "login": "dimkarakostas",
      "id": 8135971,
      "node_id": "MDQ6VXNlcjgxMzU5NzE=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/8135971?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dimkarakostas",
      "html_url": "https://github.com/dimkarakostas",
      "followers_url": "https://api.github.com/users/dimkarakostas/followers",
      "following_url": "https://api.github.com/users/dimkarakostas/following{/other_user}",
      "gists_url": "https://api.github.com/users/dimkarakostas/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dimkarakostas/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dimkarakostas/subscriptions",
      "organizations_url": "https://api.github.com/users/dimkarakostas/orgs",
      "repos_url": "https://api.github.com/users/dimkarakostas/repos",
      "events_url": "https://api.github.com/users/dimkarakostas/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dimkarakostas/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Timestamping does not try to prevent anyone from timestamping blocks, it only ensures that a single chain is (irreversibly) accepted as canonical. Once the first block of a specific height is timestamped, then it acts as a checkpoint (regardless of who created it) and no party that follows the timestamping mechanism will revert it in the future (thus preventing deep chain reorgs). In other words, allowing an attacker to timestamp blocks is acceptable under this model; what is not acceptable is reorganizing a block that has been timestamped and has been adopted as the local chain.",
    "created_at": "2020-09-01T14:08:41Z",
    "updated_at": "2020-09-01T14:08:42Z",
    "html_url": "https://github.com/ethereumclassic/ECIPs/pull/347#discussion_r481165339",
    "pull_request_url": "https://api.github.com/repos/ethereumclassic/ECIPs/pulls/347",
    "author_association": "NONE",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/ethereumclassic/ECIPs/pulls/comments/481165339"
      },
      "html": {
        "href": "https://github.com/ethereumclassic/ECIPs/pull/347#discussion_r481165339"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/ethereumclassic/ECIPs/pulls/347"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 132,
    "side": "RIGHT",
    "in_reply_to_id": 479031186
  }