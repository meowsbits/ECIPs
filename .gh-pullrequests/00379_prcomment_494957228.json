{
    "url": "https://api.github.com/repos/ethereumclassic/ECIPs/pulls/comments/494957228",
    "pull_request_review_id": 496378641,
    "id": 494957228,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk1NzIyOA==",
    "diff_hunk": "@@ -36,33 +53,33 @@ If Ethereum Classic is to succeed as a project, we need to take what we have lea\n \n \n ### Reason 2: Value to Smart Contract Developers\n-In Solidity, developers have access to the `keccak256()` function, which allows a smart contract to efficiently calculate the hash of a given input. This has been used in a number of interesting projects launched on both Ethereum and Ethereum-Classic. Most Specifcally a project called 0xBitcoin [4] - which the ERC-918 spec was based on.\n+In Solidity, developers have access to the `keccak256()` function, which allows a smart contract to efficiently calculate the hash of a given input. This has been used in a number of interesting projects launched on both Ethereum and Ethereum-Classic. Most Specifically a project called 0xBitcoin [4] - which the ERC-918 spec was based on.\n \n 0xBitcoin is a security-audited [5] dapp that allows users to submit a proof of work hash directly to a smart contract running on the Ethereum blockchain. If the sent hash matches the given requirements, a token reward is trustlessly dispensed to the sender, along with the contract reevaluating difficulty parameters. This project has run successfully for over 10 months, and has minted over 3 million tokens [6].\n \n With the direction that Ethereum Classic is taking: a focus on Layer-2 solutions and cross-chain compatibility; being able to evaluate proof of work on chain, will be tremendously valuable to developers of both smart-contracts and node software writers. This could greatly simplify interoperability. \n \n-### Implementation\n-\n-Work in Progress:\n+## Implementation\n \n-Example of a Smart contract hashing being able to trustlessly Keccak hash a hypothetical block header.\n+Example of a Smart contract hashing being able to trustlessly Keccak-256 hash a hypothetical block header.\n ![example](https://i.imgur.com/xh3WgCF.png)\n \n-Here is an analysis of Monero's nonce-distribution for \"cryptonight\", an algorithm similar to Ethash, which also attempts to be \"ASIC-Resistant\" it is very clear in the picture that before the hashing algorithm is changed there is a clear nonce-pattern. This is indicative of a major failure in a hashing algorithm, and should illustrate the dangers of disregarding proper cryptographic security. Finding a hashing pattern would be far harder using a proven system like Keccak:\n+Here is an analysis of Monero's nonce-distribution for \"cryptonight\", an algorithm similar to Ethash, which also attempts to be \"ASIC-Resistant\" it is very clear in the picture that before the hashing algorithm is changed there is a clear nonce-pattern. This is indicative of a major failure in a hashing algorithm, and should illustrate the dangers of disregarding proper cryptographic security. Finding a hashing pattern would be far harder using a proven system like Keccak-256:\n \n ![example](https://i.imgur.com/vVdmzm9.jpg)",
    "path": "_specs/ecip-1049.md",
    "position": 84,
    "original_position": 85,
    "commit_id": "3e6f7e42f08bf54bc09c3afbe82d6d0497c551f8",
    "original_commit_id": "921e13ebcd1e8cb00e8acd2b75af8203fded9dd5",
    "user": {
      "login": "q9f",
      "id": 58883403,
      "node_id": "MDQ6VXNlcjU4ODgzNDAz",
      "avatar_url": "https://avatars1.githubusercontent.com/u/58883403?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/q9f",
      "html_url": "https://github.com/q9f",
      "followers_url": "https://api.github.com/users/q9f/followers",
      "following_url": "https://api.github.com/users/q9f/following{/other_user}",
      "gists_url": "https://api.github.com/users/q9f/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/q9f/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/q9f/subscriptions",
      "organizations_url": "https://api.github.com/users/q9f/orgs",
      "repos_url": "https://api.github.com/users/q9f/repos",
      "events_url": "https://api.github.com/users/q9f/events{/privacy}",
      "received_events_url": "https://api.github.com/users/q9f/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "From #380?",
    "created_at": "2020-09-25T12:36:02Z",
    "updated_at": "2020-09-27T17:36:35Z",
    "html_url": "https://github.com/ethereumclassic/ECIPs/pull/379#discussion_r494957228",
    "pull_request_url": "https://api.github.com/repos/ethereumclassic/ECIPs/pulls/379",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/ethereumclassic/ECIPs/pulls/comments/494957228"
      },
      "html": {
        "href": "https://github.com/ethereumclassic/ECIPs/pull/379#discussion_r494957228"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/ethereumclassic/ECIPs/pulls/379"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 69,
    "original_line": 69,
    "side": "RIGHT",
    "in_reply_to_id": 490250411
  }