{
    "id": 478918318,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODkxODMxOA==",
    "url": "https://api.github.com/repos/ethereumclassic/ECIPs/pulls/comments/478918318",
    "pull_request_review_id": 477419405,
    "diff_hunk": "@@ -0,0 +1,450 @@\n+---\n+lang: en\n+ECIP: ECIP-XXX\n+Title: Proto Treasury System \n+Author: Julian Mendiola, Nicolas Tallar, Brian McKenna \n+Discussions-To: https://github.com/ethereumclassic/ECIPs/issues/350 | https://github.com/input-output-hk/ECIPs/issues/2\n+Status: Draft\n+Type: Standards Track\n+Category: Core\n+Created: 2020-08-26\n+---\n+\n+### Abstract\n+This document outlines a proposal for the implementation of a proto-treasury system in Ethereum Classic.  It describes the high-level structure of the **proto-Ethereum Classic Treasury System (p-ECTS**), and its general properties. Detailed specifications for each part of the system, as well as reference implementation, can be found in the [GitHub repository]( https://github.com/input-output-hk/etc_treasury_system).\n+\n+### Motivation\n+The primary motives of the p-ECTS is to establish a stable and reliable funding mechanism for independent teams, each of whom are capable of both maintaining core clients and evolving the development of the Ethereum Classic platform, as well as initiating the funding of a Gitcoin grants pool for wider community development. \n+\n+The current approach of relying on voluntarism and benefactors to support the ETC eco-system has failed. A clear signal needs to be sent to the wider community that ETC means to move forward with confidence with a clear vision to deliver a stable stream of funding that encourages developer engagement.\n+\n+To realise this ambitious vision, innovation must be encouraged and the ETC network must be consistently maintained and continuously improved. Blockchain protocols are highly complex distributed systems that are proven to be expensive to research, develop, and implement while operating within an  increasingly competitive developer market. ETC needs to position itself as a desirable platform for innovation where developers want to invest their time making improvements and building new applications.\n+\n+ETC can gain significant competitive advantage in the medium and long-term outlook by delivering a stable, decentralized and community-driven funding system for protocol development that is backed by a clear technical roadmap. To achieve this goal, stable and reliable funding is required, under the transparent and verifiable control of the Ethereum Classic community, through the ECIP process. With full transparency, proposals can be thoroughly questioned and rigorously examined by fellow community members, with community members themselves making collective funding decisions.\n+\n+ETC needs a vision to inspire developers - particularly those currently outside the ETC ecosystem, to build on the platform, ahead of the many other well-funded competitor platforms in the space. This treasury system is designed to do this quickly and efficiently and having a high value ETC will also mitigate against potential 51% attacks.\n+\n+We recognise this proposal outlines a significant change to the future governance of ETC. For this reason, we are proposing an element of built in obsolescence so the community has the opportunity to directly assess the value of the treasury system and in time, actively vote for its continuation and further development or indeed to allow it to be reversed.\n+\n+This proposal is not designed to deliver an end-state system, but a stepping stone solution on the path to the launch of a fully decentralized treasury system.\n+\n+\n+### Specification\n+\n+#### Solution Overview and Rationale \n+\n+This proposal opts for the most simple solution for the p-ECTS to encourage collaboration and transparency for this first-step treasury system.\n+\n+This specification represents the p-ECTS only, and a best-in-class treasury and governance model, such as outlined in [[1]](https://eprint.iacr.org/2018/435.pdf\n+), can be proposed by the community via the ECIP mechanism in the future.\n+\n+We would also put forward that this treasury system would go through a formal verification process to ensure that it behaves as per the final specification.\n+\n+#### Parameters\n+\n+| Name | Description | Proposed value |\n+|---|---|---|\n+|**FORK_BLKNUM**|Block on which the Hard Fork will take place.|TBD|\n+|**Initial client members addresses**|Collections of all MemberType.Client.|TBD|\n+|**gitcoinAddress**|Gitcoin grant address.|TBD|\n+|**treasuryBlockReward**|Amount of ETC received by the treasury.|20% portion of the block reward|\n+|**gitcoinRewardPerc**|Percentage of reward that the MemberType.Gitcoin will receive.|10%|\n+|**proposalMinDeposit**| Minimum amount of ETC required to submit a proposal.|100 ETC|\n+|**proposalDebatePeriod**| Amount of time the proposal can be voted on.|30 days|\n+|**proposalPreSupportPeriod**| Amount of time before the proposal voting deadline, on which the pre_support_flag can be evaluated.|2 days|\n+|**proposalMinQuourum**| Minimum amount of ETC required to have participated in voting for a proposal (either yes/no) to be considered applicable. | 1/3 of total ETC supply (*)|\n+|**proposalMajorityPerc**| Percentage of majority (yes over no votes) required for any proposal to be passed.|60%|\n+|**lockedWaitingTime**| Time since funds are locked until they can be used for proposal voting.|1 day|\n+|**shutdownGacePeriod**| Period of time after a shutdown proposal has been approved, where proposals can no longer be submitted, but funds can be recovered.|7 days|\n+\n+(*) Obtaining the exact total supply from a smart contract is not easy, and we'll probably need to make some estimations, like taking the average of a lower and upper bound.\n+\n+#### Data Dictionary\n+\n+- **Member**: Entity that will receive funding, identified by an address.\n+- **MemberType**: \n+    - Client\n+    - Gitcoin\n+- **N**: number of active MemberType.Client to receive funding on a given time.\n+\n+#### Protocol changes: Treasury Fund\n+\n+Currently, when a block is successfully mined on the Ethereum Classic blockchain, the miner receives 3.2 ETC as a block reward. For now, all rewards and fees are taken by the miners who have produced the blocks; it is possible to take a portion of the reward to fund the treasury.  This change proposes that the block reward is adjusted so that:\n+- 80% of the block reward goes to the miners\n+- 20% goes to the p-ECTS smart contract address or the burn address (0x0)\n+(note: transaction fees will not be included in the treasury fund)\n+\n+The miner will be able to choose whether they want to send the 20% to the defined address, or burn the funds completely. \n+\n+In the special case where the treasury contracts have been shut off, the miner will reclaim the 20% and receive the full block reward.\n+\n+The funds allocation for the treasury contract, or the burn address, will be allocated in the same way as the coinbase funds. That is, with direct intervention on the balance of those accounts.\n+\n+\n+#### Funds distribution\n+\n+Treasury funds will be held in escrow in the p-ECTS smart contract. Capability to withdraw from the p-ECTS will be limited to the contract members, initially three *MemberType.Client*  for the core ETC development teams and a single *MemberType.Gitcoin* Gitcoin grant.\n+\n+Funds will be distributed as follows:\n+\n+    gitcoinFunds = treasuryBlockReward * gitcoinRewardPerc\n+    clientFunds =  (treasuryBlockReward - gitcoinReward) / N \n+\n+_Note that if the division by N might has some leftover dust, it will be \"collected\" by future distributions._\n+\n+So, for example for the initial proposed state, on which we have three client members, the distribution will be:\n+\n+- *Gitcoin grant*: 10%\n+- *Client Member 1*: 30%\n+- *Client Member 2*: 30%\n+- *Client Member 3*: 30%\n+\n+\n+Note that as the funds are allocated directly on the treasury contract address, a transaction will be needed to actually distribute ( *distributeFunds()*) them and make them available for withdrawal to each of the members, then each one will need an extra call to do so ( *withdrawFunds()*). \n+As *distributeFunds* considers the state of the contract at that moment, itâ€™s important that any method that alters this state, first executes it.\n+\n+#### Governance of p-ECTS\n+\n+##### Proposal and voting mechanics\n+\n+Governance participation is open to all ETC holders who can vote on any proposed changes to the p-ECTS. \n+\n+Votes will be counted as total locked ETC that has participated (voted yes/no) on each proposal.\n+\n+Anyone can submit a new proposal to update the p-ECTS, but they need to include a minimum amount of funds (*proposalMinDeposit*), those funds will be locked until the proposal ends (not *active*) and will be counted as *yes* votes.\n+\n+A similar lockdown mechanism applies for the voting, the voter will need to lock their funds for *lockedWaitingTime* until they're elegible and they can cast any vote with them. If the same user wants to register more funds with the same address, all their previous funds will be locked for the new *lockedWaitingTime* period as well.\n+\n+Participants will be able to unlock these funds and take them back, as long as they are not currently being used as votes on another proposal in progress.\n+\n+Participants can use the same eligible stake for voting simultaneously on any proposals under consideration.\n+\n+Participants can change their vote at any time during the proposal period, but all their funds will be taken into account and they will all need to be unlocked. For example, if I vote *yes* with 10ETC, then lock an extra 5ETC, wait the *lockedWaitingTime* and now re-vote as *no*, this will count as a 15ETC *no* vote.\n+\n+Participants, with the exception of the proposal submitter, can also unregister votes, and the same locking funds restrictions apply. For example, if I vote *yes* with 10ETC, then lock an extra 5ETC, wait the *lockedWaitingTime* and now unregister my votes, naturally, only my 10ETC *yes* vote will be revoked. The funds however, will remain blocked for withdrawl until the proposal finihed.\n+\n+A proposal lifecycle for updates to p-ECTS consists of the following phases, delimited with certain events:\n+    - **Proposal creation event**: The proposal gets created, its author's stake is registered as a *yes* vote and it immediately enters the *voting phase*.\n+    - **Voting phase**: Since creation, and up to *proposalCreationTime* + *proposalDebatePeriod*; the proposal can register new votes, change votes or unvote.\n+    - **Proposal pre-support event**: Before the proposal's voting ends, there is a *proposalPreSupportPeriod* in which the *preSupport* flag can be evaluated. If a majority has voted yes and has a quorum, this flag will be activated, which is a pre-condition for the proposal to pass. (See: [Ambush attacks prevention](#ambush-attacks-prevention) Section)\n+    - **Proposal voting deadline event**: After *proposalCreationTime* + *proposalDebatePeriod*, the proposal no longer accepts votes, meaning that the proposal outcome is settled at this moment.\n+    - **Proposal execution phase**: After the deadline event, if the proposal gets approved, it's publicly available to be executed, making the change effective immediately.\n+    \n+##### Proposal approval criteria\n+\n+- The Treasury cannot be in shutdown state.\n+- It needs to be active (have not been executed before) and have completed the *proposalDebatePeriod*.\n+- It needs to have the pre-support flag on.\n+- It needs to have reached minimun quorum. Meaning that the sum of all yes and no votes has to be equal, or bigger than *proposalMinQuorum* at closing time.\n+- It needs to have majority consensus, meaning that amount of *yes votes*, over *no votes*, needs to be equal or bigger than *proposalMajorityPerc*.\n+\n+\n+##### Members add & remove\n+\n+Through the proposal mechanism, the community has the power to **remove a member** from the p-ECTS. It can be both a MemberType.Client or MemberType.Gitcoin.\n+\n+The community also has the power to **add members** to the p-ECTS. Only MemberType.Client can be added. There is no limit to the number of clients.\n+\n+##### Members address update\n+\n+Through the proposal mechanism, the community has the power to **update a member address** from the p-ECTS. It can be both a MemberType.Client or MemberType.Gitcoin.\n+The fundamental difference with remove/add is that in this case, the accumulated funds for this member remain available for them to withdraw, using this updated address.\n+This is particularly useful if a member loses their private keys or their keys become compromised.\n+It applies for all MemberTypes.\n+\n+Please also review the [Notes section](#client-account-maintenance) on this topic.\n+\n+\n+##### Treasury shutdown\n+\n+Through the proposal mechanism, the community has the power to shut down the p-ECTS, and from that point forward the full block reward will revert to the miners.\n+\n+The shutdown is carried out in two steps. First, the proposal execution sets the *shutdownScheduledAt* time and the *shutdownGracePeriod* starts. During this time, no new proposal can be submitted, nor votes cast. Also, all the funds are unblocked and available to be withdrawn.\n+Secondly, after *shutdownGracePeriod*, the actual shutdown method is enabled and the contract can be effectively self destructed. The operation is irreversible, and whatever funds are left in it, become \"burned\".\n+\n+\n+#### Interface\n+\n+```sol\n+interface ITreasury {\n+\n+    // ---------------------\n+    // EVENTS\n+    // ---------------------\n+\n+    /// @dev emitted when a proposal to add a new client is created\n+    event AddClientProposal(uint256 _proposalID, address submitter, address clientToAdd);\n+\n+    /// @dev emitted when a proposal to remove a client is created\n+    event RemoveClientProposal(uint256 _proposalID, address submitter, address clientToRemove);\n+\n+    /// @dev emitted when a proposal to remove gitcoin is created\n+    event RemoveGitcoinProposal(uint256 _proposalID, address submitter);\n+\n+    /// @dev emitted when a proposal to update the address of a member is created\n+    event UpdateMemberAddressProposal(uint256 _proposalID, address submitter, address oldClientAddress, address newClientAddress);\n+\n+    /// @dev emitted when a proposal to shutdown treasury is created\n+    event ShutdownProposal(uint256 _proposalID, address submitter);\n+\n+\n+    /// @dev emitted when a client is added (after proposal execution)\n+    event ClientAdded(address clientAdded);\n+\n+    /// @dev emitted when a client is removed (after proposal execution)\n+    event ClientRemoved(address clientRemoved);\n+\n+    /// @dev emitted when a member address is updated (after proposal execution)\n+    event MemberAddressUpdated(address oldClientAddress, address newClientAddress);\n+\n+    /// @dev emitted when gitcoin is removed (after proposal execution)\n+    event GitcoinRemoved();\n+\n+    /// @dev emitted when shutdown is scheduled (after proposal execution)\n+    event ShutdownScheduled();\n+\n+    /// @dev emitted when an unsuccessful proposal is closed\n+    event ClosedProposal(uint256 _proposalID);\n+\n+\n+    // ---------------------\n+    // WITHDRAWAL\n+    // ---------------------\n+\n+    /// @notice Accepts donations \n+    receive() external payable;\n+\n+    /// @notice Calculates the funds corresponding to each member based on this.balance,\n+    ///         distributing the accordingly, for future withdraw by each member\n+    function distributeFunds() external;\n+\n+    /// @notice Withdraws pending funds corresponding to the sender\n+    /// @return Whether the withdraw was successful or not\n+    function withdrawFunds() external returns(bool);\n+\n+\n+    // ---------------------\n+    // LOCKING/UNLOCKING\n+    // ---------------------\n+\n+    /// @notice Locks transfered funds on the smart contract, to be eventually used for\n+    ///         voting proposals. The sender won't be able to use any of their locked\n+    ///         funds (including previous locks) till locked_waiting_time time passes\n+    /// @return Whether lock was successful or not\n+    function lockFunds() external payable returns(bool);\n+\n+\n+    /// @notice Partially unlocks senders' funds and transfers them back to the owner\n+    /// @param amount Funds (in wei) that the sender wants to remove\n+    function unlockFunds(uint256 amount) external;\n+\n+\n+    // ---------------------\n+    // PROPOSAL CREATION\n+    // ---------------------\n+\n+    /// @notice Creates a proposal for adding a new client\n+    ///         The sender needs to send at least proposalMinDeposit, which will be exclusively\n+    ///         used for this proposal (and will count as positive votes) and will return to the\n+    ///         creator once the proposal is executed or closed\n+    /// @param clientToAdd the new client to be added if the proposal succeeds\n+    function proposeAddClient(address clientToAdd) payable external;\n+\n+    /// @notice Creates a proposal for adding a removing member\n+    ///         The sender needs to send at least proposalMinDeposit, which will be exclusively\n+    ///         used for this proposal (and will count as positive votes) and will return to the\n+    ///         creator once the proposal is executed or closed\n+    /// @param clientToRemove the existing member to be removed if the proposal succeeds\n+    function proposeRemoveClient(address clientToRemove) payable external;\n+\n+    /// @notice Creates a proposal for updating a member address\n+    ///         The sender needs to send at least proposalMinDeposit, which will be exclusively\n+    ///         used for this proposal (and will count as positive votes) and will return to the\n+    ///         creator once the proposal is executed or closed\n+    /// @param memberToUpdate the existing member to be updated if the proposal succeeds\n+    /// @param newMemberAddress new member address\n+    function proposeUpdateMemberAddress(address memberToUpdate, address newMemberAddress) payable external;\n+\n+    /// @notice Creates a proposal for removing the gitcoin member\n+    ///         The sender needs to send at least proposalMinDeposit, which will be exclusively\n+    ///         used for this proposal (and will count as positive votes) and will return to the\n+    ///         creator once the proposal is executed or closed\n+    function proposeRemoveGitcoin() payable external;\n+\n+    /// @notice Creates a proposal for shutting down treasury\n+    ///         The sender needs to send at least proposalMinDeposit, which will be exclusively\n+    ///         used for this proposal (and will count as positive votes) and will return to the\n+    ///         creator once the proposal is executed or closed\n+    function proposeShutdown() payable external;\n+\n+\n+    // ---------------------\n+    // PROPOSAL VOTING\n+    // ---------------------\n+\n+    /// @notice Vote for a proposal, with all your unlocked staked\n+    ///         Requires:\n+    ///          - voting period to not have ended\n+    ///          - any locked locks already available for usage\n+    /// @param _proposalID of the proposal being voted on\n+    /// @param _supportsProposal whether the vote is in favour or against it\n+    function vote(uint256 _proposalID, bool _supportsProposal) external;\n+\n+    /// @notice Remove the vote for a proposal\n+    /// @param _proposalID of the proposal from where votes are being removed\n+    function unvote(uint _proposalID) external;\n+\n+\n+    // ---------------------\n+    // PROPOSAL EXECUTION\n+    // ---------------------\n+\n+    /// @notice Pre-approves a proposal that already reached quorum and majority in favour\n+    /// @param _proposalID Id of the proposal being pre-approved\n+    function preApprove(uint _proposalID) external;\n+\n+    /// @notice Executes the proposal, calling first distributeFunds and then applying the effects of it\n+    ///         - Added/removed member (including gitcoin) results in change in the distribution since next block\n+    ///         - Updated member address results in pending and future funds for previous address to\n+    ///           be given to the new one\n+    ///         - Shutdown results in it to be scheduled after the shutdownGracePeriod\n+    /// @param _proposalID Id of the proposal to execute\n+    /// @param clientIndex For client removeal or update, the index on the members array should be passed\n+    function execProposal(uint256 _proposalID, uint256 clientIndex) external;\n+\n+    /// @notice Closes an unsuccessful proposal. A proposal is considered unsuccessful if:\n+    ///          - it wasn't pre-approved\n+    ///          - since pre-support it lost it's quorum or majority in favour of it\n+    /// @param _proposalID Id of the proposal to close\n+    function closeProposal(uint256 _proposalID) external;\n+\n+    /// @notice Allows a proposal creator to recover it's deposit once the proposal has been\n+    ///         closed or executed\n+    /// @param _proposalID Id of the proposal the deposit is being recovered\n+    function recoverProposalDeposit(uint _proposalID) external;\n+\n+\n+    // ---------------------\n+    // SHUTDOWN\n+    // ---------------------\n+\n+    /// @notice Executes the shutdown and selfdestructs the contract\n+    ///         Requires a shutdown to have been scheduled shutdownGracePeriod before\n+    function shutdown() external;\n+\n+\n+    // ---------------------\n+    // QUERYING\n+    // ---------------------\n+\n+    /// @notice Returns the available balance the member can withdraw at this moment\n+    function getAvailableWithdrawBalance(address memberAddress) external view returns(uint256);\n+\n+    /// @notice true if there locked funds are not been blocked by a debating poposal \n+    function canUnlockFunds() external view returns(bool);\n+\n+    /// @notice Returns the amount locked by a participant\n+    /// @param participant address from which we desire to query the amount of funds\n+    /// @return amount locked with the participant\n+    function getLockedAmount(address participant) external view returns(uint256);\n+\n+    /// @notice Returns the amount of active members of client type.\n+    function getClientMembersSize() external view returns(uint256);\n+    \n+    /// @notice Returns the address and the name of the Client member in the index array position\n+    function getClientMemberAt(uint256 index) external view returns(address, string memory);\n+    \n+    /// @notice Returns the address of the gitcoin members.\n+    function getGitcoinAddress() external view returns(address);\n+\n+    /// @notice Returns the state of a proposal\n+    /// @return active whether the proposal was executed/closed or not\n+    /// @return preSupport whether the proposal has been pre-approved or not\n+    /// @return proposedAtTime time when the proposal was created\n+    /// @return endsAtTime time when the proposal voting period will end and it will be open to closing/executing\n+    /// @return yesVotes amount of stake in favour of the proposal\n+    /// @return noVotes amount of stake against a proposal\n+    function getProposalState(uint256 proposalId) external view returns(bool active, bool preSupport, uint256 proposedAtTime, uint256 endsAtTime, uint256 yesVotes, uint256 noVotes);\n+\n+    /// @notice true if there a proposal for shutdown was executed \n+    function withShutdownInProgress() external view returns(bool);\n+}\n+```\n+\n+#### Notes and considerations\n+\n+##### Client account maintenance\n+\n+In the event that a client funding account has been lost or compromised, we had incorporated a proposal type (*ProposalType.UpdateClientAddress*) to make the change, but going through the proposal process to make such a update might be overkill and there is no need to involve the whole community in something that is solely the client's responsibility.\n+\n+We suggest an alternative mechanism to cover this, in which each client would have two different sets of keys; one **spending key** that would allow them to manage their funds and acts as a *hot wallet* and a second one that can act as a **revocation key/certificate**. This second key doesn't neccessarily have to be an ETC account but could follow another standard (such as PGP for example).\n+This would facilitate the client in making a more frequent rotation of their spending keys in a secure way.\n+\n+##### Ambush attacks prevention\n+\n+**Ambush attack**: \"Surprise\" that a huge approval is given to a proposal at the last minute. A proposal that seems to be going towards a \"No\" outcome, suddenly receives a big amount of yes votes and the result is flipped at the last minute.\n+\n+**Prevention**: Successful proposals require early pre-support, which already raises warnings that this approval might go through, so anyone that wants to counteract, can intervene during this period.",
    "path": "_specs/ecip-proto-treasury-system.md",
    "position": null,
    "original_position": 387,
    "commit_id": "5ceffe58467842b93305adbd8007204c76338df0",
    "user": {
      "login": "q9f",
      "id": 58883403,
      "node_id": "MDQ6VXNlcjU4ODgzNDAz",
      "avatar_url": "https://avatars2.githubusercontent.com/u/58883403?u=72563674ea84909432bf249ab92fb936dffa313d&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/q9f",
      "html_url": "https://github.com/q9f",
      "followers_url": "https://api.github.com/users/q9f/followers",
      "following_url": "https://api.github.com/users/q9f/following{/other_user}",
      "gists_url": "https://api.github.com/users/q9f/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/q9f/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/q9f/subscriptions",
      "organizations_url": "https://api.github.com/users/q9f/orgs",
      "repos_url": "https://api.github.com/users/q9f/repos",
      "events_url": "https://api.github.com/users/q9f/events{/privacy}",
      "received_events_url": "https://api.github.com/users/q9f/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "> _require early pre-support_\r\n\r\nis this specified somehow?",
    "created_at": "2020-08-28T08:07:30Z",
    "updated_at": "2020-08-28T21:41:17Z",
    "html_url": "https://github.com/ethereumclassic/ECIPs/pull/349#discussion_r478918318",
    "pull_request_url": "https://api.github.com/repos/ethereumclassic/ECIPs/pulls/349",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/ethereumclassic/ECIPs/pulls/comments/478918318"
      },
      "html": {
        "href": "https://github.com/ethereumclassic/ECIPs/pull/349#discussion_r478918318"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/ethereumclassic/ECIPs/pulls/349"
      }
    },
    "original_commit_id": "fe5fe9e05a7cdb49ec4be090aea0d5f63470fd8b"
  }