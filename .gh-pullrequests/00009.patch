From f646687c74a83f900d2346e65d48bc2ef4684fbe Mon Sep 17 00:00:00 2001
From: realcodywburns <cody.w.burns@gmail.com>
Date: Sat, 12 Jan 2019 20:50:29 -0600
Subject: [PATCH 1/2] krykoder sucks push

---
 ECIPs/ECIP-1000.mediawiki | 317 ++++++++++++++++++++
 ECIPs/ECIP-1016.md        |  23 ++
 ECIPs/ECIP-1018.md        |  84 ++++++
 ECIPs/ECIP-1019.md        |  87 ++++++
 ECIPs/ECIP-1022.md        | 189 ++++++++++++
 ECIPs/ECIP-1023.md        |  66 +++++
 ECIPs/ECIP-1024.md        | 107 +++++++
 ECIPs/ECIP-1025.md        | 168 +++++++++++
 ECIPs/ECIP-1026.md        |  92 ++++++
 ECIPs/ECIP-1027.md        | 220 ++++++++++++++
 ECIPs/ECIP-1028.md        | 124 ++++++++
 ECIPs/ECIP-1029.md        |  32 ++
 ECIPs/ECIP-1031.md        |  29 ++
 ECIPs/ECIP-1032.md        |  71 +++++
 ECIPs/ECIP-1033.md        |  23 ++
 ECIPs/ECIP-1034.md        |  57 ++++
 ECIPs/ECIP-1035.md        | 146 +++++++++
 ECIPs/ECIP-1036.md        |  30 ++
 ECIPs/ECIP-1037.md        | 265 +++++++++++++++++
 ECIPs/ECIP-1038.md        |  67 +++++
 ECIPs/ECIP-1040.md        |  68 +++++
 ECIPs/ECIP-1042.md        |  63 ++++
 ECIPs/ECIP-1043.md        |  37 +++
 ECIPs/ECIP-1044.md        |  84 ++++++
 ECIPs/ECIP-1045.md        |  96 ++++++
 ECIPs/ECIP-1046.md        |  89 ++++++
 ECIPs/ECIP-1050.md        | 604 ++++++++++++++++++++++++++++++++++++++
 ECIPs/ECIP-1051.md        |  51 ++++
 ECIPs/ECIP-1052.md        |  75 +++++
 README.md                 |  46 +--
 30 files changed, 3389 insertions(+), 21 deletions(-)
 create mode 100644 ECIPs/ECIP-1000.mediawiki
 create mode 100644 ECIPs/ECIP-1016.md
 create mode 100644 ECIPs/ECIP-1018.md
 create mode 100644 ECIPs/ECIP-1019.md
 create mode 100644 ECIPs/ECIP-1022.md
 create mode 100644 ECIPs/ECIP-1023.md
 create mode 100644 ECIPs/ECIP-1024.md
 create mode 100644 ECIPs/ECIP-1025.md
 create mode 100644 ECIPs/ECIP-1026.md
 create mode 100644 ECIPs/ECIP-1027.md
 create mode 100644 ECIPs/ECIP-1028.md
 create mode 100644 ECIPs/ECIP-1029.md
 create mode 100644 ECIPs/ECIP-1031.md
 create mode 100644 ECIPs/ECIP-1032.md
 create mode 100644 ECIPs/ECIP-1033.md
 create mode 100644 ECIPs/ECIP-1034.md
 create mode 100644 ECIPs/ECIP-1035.md
 create mode 100644 ECIPs/ECIP-1036.md
 create mode 100644 ECIPs/ECIP-1037.md
 create mode 100644 ECIPs/ECIP-1038.md
 create mode 100644 ECIPs/ECIP-1040.md
 create mode 100644 ECIPs/ECIP-1042.md
 create mode 100644 ECIPs/ECIP-1043.md
 create mode 100644 ECIPs/ECIP-1044.md
 create mode 100644 ECIPs/ECIP-1045.md
 create mode 100644 ECIPs/ECIP-1046.md
 create mode 100644 ECIPs/ECIP-1050.md
 create mode 100644 ECIPs/ECIP-1051.md
 create mode 100644 ECIPs/ECIP-1052.md

diff --git a/ECIPs/ECIP-1000.mediawiki b/ECIPs/ECIP-1000.mediawiki
new file mode 100644
index 00000000..adf71c11
--- /dev/null
+++ b/ECIPs/ECIP-1000.mediawiki
@@ -0,0 +1,317 @@
+<pre>
+  ECIP: 2
+  Title: ECIP process
+  Author: Wei Tang <hi@that.world>
+  Comments-Summary: No comments yet.
+  Comments-URI: No wiki links yet.
+  Status: Draft
+  Type: Process
+  Created: 2017-06-29
+  License: Apache-2
+</pre>
+
+==Abstract==
+
+An Ethereum Classic Improvement Proposal (ECIP) is a design document providing information to the Ethereum Classic community, or describing a new feature for Ethereum Classic or its processes or environment. The ECIP should provide a concise technical specification of the feature and a rationale for the feature.
+
+We intend ECIPs to be the primary mechanisms for proposing new features, for collecting community input on an issue, and for documenting the design decisions that have gone into Ethereum Classic. The ECIP author is responsible for building consensus within the community and documenting dissenting opinions.
+
+Because the ECIPs are maintained as text files in a versioned repository, their revision history is the historical record of the feature proposal.
+
+==Copyright==
+
+This ECIP is licensed Apache-2, originally by Luke Dashjr <luke+ECIP@dashjr.org> under BSD 2-clause license.
+
+==ECIP workflow==
+
+The ECIP process begins with a new idea for Ethereum Classic. Each potential ECIP must have a champion -- someone who writes the ECIP using the style and format described below, shepherds the discussions in the appropriate forums, and attempts to build community consensus around the idea. The ECIP champion (a.k.a. Author) should first attempt to ascertain whether the idea is ECIP-able.
+Small enhancements or patches to a particular piece of software often don't require standardisation between multiple projects; these don't need an ECIP and should be injected into the relevant project-specific development workflow with a patch submission to the applicable issue tracker.
+Additionally, many ideas have been brought forward for changing Ethereum Classic that have been rejected for various reasons.
+The first step should be to search past discussions to see if an idea has been considered before, and if so, what issues arose in its progression.
+After investigating past work, the best way to proceed is by posting about the new idea to the [https://ethereumclassic.slack.com Ethereum Classic Slack Channel].
+
+Vetting an idea publicly before going as far as writing a ECIP is meant to save both the potential author and the wider community time.
+Asking the Ethereum Classic community first if an idea is original helps prevent too much time being spent on something that is guaranteed to be rejected based on prior discussions (searching the internet does not always do the trick).
+It also helps to make sure the idea is applicable to the entire community and not just the author. Just because an idea sounds good to the author does not mean it will work for most people in most areas where Ethereum Classic is used.
+
+Once the champion has asked the Ethereum Classic community as to whether an idea has any chance of acceptance, a draft ECIP should be submitted to the [https://github.com/ethereumproject/ECIPs ECIPs git repository] as a pull request. This gives the author a chance to flesh out the draft ECIP to make it properly formatted, of high quality, and to address additional concerns about the proposal. This draft must be written in ECIP style as described below, and named with an alias such as "ecip-johndoe-infinitebitcoins" until the editor has assigned it a ECIP number (authors MUST NOT self-assign ECIP numbers).
+
+ECIP authors are responsible for collecting community feedback on both the initial idea and the ECIP before submitting it for review. However, wherever possible, long open-ended discussions on public mailing lists should be avoided. Strategies to keep the discussions efficient include: setting up a separate SIG mailing list for the topic, having the ECIP author accept private comments in the early design phases, setting up a wiki page or git repository, etc. ECIP authors should use their discretion here.
+
+It is highly recommended that a single ECIP contain a single key proposal or new idea. The more focused the ECIP, the more successful it tends to be. If in doubt, split your ECIP into several well-focused ones.
+
+When the ECIP draft is complete, the ECIP editor will assign the ECIP a number, label it as Standards Track, Informational, or Process, and merge the pull request to the ECIPs git repository.
+The ECIP editor will not unreasonably reject a ECIP.
+Reasons for rejecting BECPs include duplication of effort, disregard for formatting rules, being too unfocused or too broad, being technically unsound, not providing proper motivation or addressing backwards compatibility, or not in keeping with the Ethereum Classic philosophy.
+For a ECIP to be accepted it must meet certain minimum criteria.
+It must be a clear and complete description of the proposed enhancement.
+The enhancement must represent a net improvement.
+The proposed implementation, if applicable, must be solid and must not complicate the protocol unduly.
+
+The ECIP author may update the draft as necessary in the git repository. Updates to drafts should also be submitted by the author as pull requests.
+
+===Transferring ECIP Ownership===
+
+It occasionally becomes necessary to transfer ownership of ECIPs to a new champion. In general, we'd like to retain the original author as a co-author of the transferred ECIP, but that's really up to the original author. A good reason to transfer ownership is because the original author no longer has the time or interest in updating it or following through with the ECIP process, or has fallen off the face of the 'net (i.e. is unreachable or not responding to email). A bad reason to transfer ownership is because you don't agree with the direction of the ECIP. We try to build consensus around a ECIP, but if that's not possible, you can always submit a competing ECIP.
+
+If you are interested in assuming ownership of a ECIP, send a message asking to take over, addressed to both the original author and the ECIP editor. If the original author doesn't respond to email in a timely manner, the ECIP editor will make a unilateral decision (it's not like such decisions can't be reversed :).
+
+===ECIP Editors===
+
+To be added.
+
+===ECIP Editor Responsibilities & Workflow===
+
+For each new ECIP it should first be submitted as a "pull request" to the [https://github.com/ethereumproject/ECIPs ECIPs git repository] that comes in an editor does the following:
+
+* Read the ECIP to check if it is ready: sound and complete. The ideas must make technical sense, even if they don't seem likely to be accepted.
+* The title should accurately describe the content.
+* Motivation and backward compatibility (when applicable) must be addressed.
+* The defined Layer header must be correctly assigned for the given specification.
+* Licensing terms must be acceptable for ECIPs.
+
+If the ECIP isn't ready, the editor will send it back to the author for revision, with specific instructions.
+
+Once the ECIP is ready, the ECIP editor will:
+
+* Assign a ECIP number in the pull request.
+* Merge the pull request when it is ready.
+* List the ECIP in [[README.mediawiki]]
+
+The ECIP editors are intended to fulfill administrative and editorial responsibilities. The ECIP editors monitor ECIP changes, and update ECIP headers as appropriate.
+
+==ECIP format and structure==
+
+===Specification===
+
+ECIPs should be written in mediawiki or markdown format.
+
+Each ECIP should have the following parts:
+
+* Preamble -- Headers containing metadata about the ECIP ([[#ECIP header preamble|see below]]).
+* Abstract -- A short (~200 word) description of the technical issue being addressed.
+* Copyright -- The ECIP must be explicitly licensed under acceptable copyright terms ([[#ECIP licensing|see below]]).
+* Specification -- The technical specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow competing, interoperable implementations for any of the current Ethereum Classic platforms.
+* Motivation -- The motivation is critical for ECIPs that want to change the Ethereum Classic protocol. It should clearly explain why the existing protocol is inadequate to address the problem that the ECIP solves.
+* Rationale -- The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work. The rationale should provide evidence of consensus within the community and discuss important objections or concerns raised during discussion.
+* Backwards compatibility -- All ECIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The ECIP must explain how the author proposes to deal with these incompatibilities.
+* Reference implementation -- The reference implementation must be completed before any ECIP is given status "Final", but it need not be completed before the ECIP is accepted. It is better to finish the specification and rationale first and reach consensus on it before writing code. The final implementation must include test code and documentation appropriate for the Ethereum Classic protocol.
+
+====ECIP header preamble====
+
+Each ECIP must begin with an RFC 822 style header preamble. The headers must appear in the following order. Headers marked with "*" are optional and are described below. All other headers are required.
+
+    ECIP: (ECIP number, or "?" before being assigned)
+  * Layer: (Consensus (soft fork) | Consensus (hard fork) | Peer Services | API/RPC | Applications)
+    Title: (ECIP title; maximum 44 characters) 
+    Author: (authors real names and email addrs)
+  * Discussions-To: (email address)
+    Comments-Summary: (summary tone)
+    Comments-URI: (links to wiki page for comments)
+    Status: (Draft | Active | Proposed | Deferred | Rejected |
+             Withdrawn | Final | Replaced | Obsolete)
+    Type: (Standards Track | Informational | Process)
+    Created: (date created on, in ISO 8601 (yyyy-mm-dd) format)
+    License: (abbreviation for approved license(s))
+  * License-Code: (abbreviation for code under different approved license(s))
+  * Requires: (ECIP number(s))
+  * Replaces: (ECIP number)
+  * Superseded-By: (ECIP number)
+
+The Layer header (only for Standards Track ECIPs) documents which layer of Ethereum Classic the ECIP applies to.
+
+The Author header lists the names and email addresses of all the authors/owners of the ECIP.
+The format of the Author header value must be
+
+  Random J. User <123@dom.ain>
+
+If there are multiple authors, each should be on a separate line following RFC 2822 continuation line conventions.
+
+While an ECIP is in private discussions (usually during the initial Draft phase), a Discussions-To header will indicate the mailing list or URL where the ECIP is being discussed. No Discussions-To header is necessary if the ECIP is being discussed privately with the author.
+
+The Type header specifies the type of ECIP: Standards Track, Informational, or Process.
+
+The Created header records the date that the ECIP was assigned a number.
+
+ECIPs may have a Requires header, indicating the ECIP numbers that this ECIP depends on.
+
+ECIPs may also have a Superseded-By header indicating that a ECIP has been rendered obsolete by a later document; the value is the number of the ECIP that replaces the current document. The newer ECIP must have a Replaces header containing the number of the ECIP that it rendered obsolete.
+
+====Auxiliary Files====
+
+ECIPs may include auxiliary files such as diagrams. Auxiliary files should be included in a subdirectory for that ECIP, or must be named ECIP-XXXX-Y.ext, where "XXXX" is the ECIP number, "Y" is a serial number (starting at 1), and "ext" is replaced by the actual file extension (e.g. "png").
+
+==ECIP types==
+
+There are three kinds of ECIP:
+
+* A Standards Track ECIP describes any change that affects most or all Ethereum Classic implementations, such as a change to the network protocol, a change in block or transaction validity rules, or any change or addition that affects the interoperability of applications using Ethereum Classic. Standards Track ECIPs consist of two parts, a design document and a reference implementation.
+* An Informational ECIP describes a Ethereum Classic design issue, or provides general guidelines or information to the Ethereum Classic community, but does not propose a new feature. Informational ECIPs do not necessarily represent a Ethereum Classic community consensus or recommendation, so users and implementors are free to ignore Informational ECIPs or follow their advice.
+* A Process ECIP describes a process surrounding Ethereum Classic, or proposes a change to (or an event in) a process. Process ECIPs are like Standards Track ECIPs but apply to areas other than the Ethereum Classic protocol itself. They may propose an implementation, but not to Ethereum Classic's codebase; they often require community consensus; unlike Informational ECIPs, they are more than recommendations, and users are typically not free to ignore them. Examples include procedures, guidelines, changes to the decision-making process, and changes to the tools or environment used in Ethereum Classic development. Any meta-ECIP is also considered a Process ECIP.
+
+==ECIP status field==
+
+===Specification===
+
+The typical paths of the status of ECIPs are as follows:
+
+<img src="ECIP-1000/process.png"></img>
+
+Champions of a ECIP may decide on their own to change the status between Draft, Deferred, or Withdrawn.
+The ECIP editor may also change the status to Deferred when no progress is being made on the ECIP.
+
+A ECIP may only change status from Draft (or Rejected) to Proposed, when the author deems it is complete, has a working implementation (where applicable), and has community plans to progress it to the Final status.
+
+ECIPs should be changed from Draft or Proposed status, to Rejected status, upon request by any person, if they have not made progress in three years. Such a ECIP may be changed to Draft status if the champion provides revisions that meaningfully address public criticism of the proposal, or to Proposed status if it meets the criteria required as described in the previous paragraph.
+
+An Proposed ECIP may progress to Final only when specific criteria reflecting real-world adoption has occurred. This is different for each ECIP depending on the nature of its proposed changes, which will be expanded on below. Evaluation of this status change should be objectively verifiable, and/or be discussed on the development mailing list.
+
+When a Final ECIP is no longer relevant, its status may be changed to Replaced or Obsolete (which is equivalent to Replaced). This change must also be objectively verifiable and/or discussed.
+
+A process ECIP may change status from Draft to Active when it achieves rough consensus on the mailing list. Such a proposal is said to have rough consensus if it has been open to discussion on the development mailing list for at least one month, and no person maintains any unaddressed substantiated objections to it. Addressed or obstructive objections may be ignored/overruled by general agreement that they have been sufficiently addressed, but clear reasoning must be given in such circumstances.
+
+====Progression to Final status====
+
+Peer services ECIPs should be observed to be adopted by at least 1% of public listening nodes for one month.
+
+API/RPC and application layer ECIPs must be implemented by at least two independent and compatible software applications.
+
+Software authors are encouraged to publish summaries of what ECIPs their software supports to aid in verification of status changes. Good examples of this at the time of writing this ECIP, can be observed in [https://github.com/bitcoin/bitcoin/blob/master/doc/BIPs.md Bitcoin Core's doc/BIPs.md file] as well as [https://github.com/schildbach/bitcoin-wallet/blob/master/wallet/README.specs Bitcoin Wallet for Android's wallet/README.specs file].
+
+These criteria are considered objective ways to observe the de facto adoption of the ECIP, and are not to be used as reasons to oppose or reject a ECIP. Should a ECIP become actually and unambiguously adopted despite not meeting the criteria outlined here, it should still be updated to Final status.
+
+===Rationale===
+
+Why is this necessary at all?
+
+* Many ECIPs with significant real-world use have been left as Draft or Proposed status longer than appropriate. By giving objective criteria to judge the progression of ECIPs, this proposal aims to help keep the Status accurate and up-to-date.
+
+What is the ideal percentage of listening nodes needed to adopt peer services proposals?
+
+* This is unknown, and set rather arbitrarily at this time. For a random selection of peers to have at least one other peer implementing the extension, 13% or more would be necessary, but nodes could continue to scan the network for such peers with perhaps some reasonable success. Furthermore, service bits exist to help identification upfront.
+
+Why is it necessary for at least two software projects to release an implementation of API/RPC and application layer ECIPs, before they become Final?
+
+* If there is only one implementation of a specification, there is no other program for which a standard interface is used with or needed.
+* Even if there are only two projects rather than more, some standard coordination between them exists.
+
+What if a ECIP is proposed that only makes sense for a single specific project?
+
+* The ECIP process exists for standardisation between independent projects. If something only affects one project, it should be done through that project's own internal processes, and never be proposed as a ECIP in the first place.
+
+==ECIP comments==
+
+===Specification===
+
+Each ECIP should, in its preamble, link to a public wiki page with a summary tone of the comments on that page.
+Reviewers of the ECIP who consider themselves qualified, should post their own comments on this wiki page.
+The comments page should generally only be used to post final comments for a completed ECIP.
+If a ECIP is not yet completed, reviewers should instead post on the applicable development mailing list thread to allow the ECIP author(s) to address any concerns or problems pointed out by the review.
+
+Some ECIPs receive exposure outside the development community prior to completion, and other ECIPs might not be completed at all. To avoid a situation where critical ECIP reviews may go unnoticed during this period, reviewers may, at their option, still post their review on the comments page, provided they first post it to the mailing list and plan to later remove or revise it as applicable based on the completed version. Such revisions should be made by editing the previous review and updating the timestamp. Reviews made prior to the complete version may be removed if they are no longer applicable and have not been updated in a timely manner (eg, within one month).
+
+Pages must be named after the full ECIP number (eg, "ECIP 0001") and placed in the "Comments" namespace.
+For example, the link for ECIP 1 will be https://github.com/ethereumproject/ECIPs/wiki/Comments:ECIP-0001 .
+
+Comments posted to this wiki should use the following format:
+
+    <Your opinion> --<Your name>, <Date of posting, as YYYY-MM-DD>
+
+ECIPs may also choose to list a second forum for ECIP comments, in addition to the ECIPs wiki.
+In this case, the second forum's URI should be listed below the primary wiki's URI.
+
+After some time, the ECIP itself may be updated with a summary tone of the comments.
+Summary tones may be chosen from the following, but this ECIP does not intend to cover all possible nuances and other summaries may be used as needed:
+
+* No comments yet.
+* Unanimously Recommended for implementation
+* Unanimously Discourage for implementation
+* Mostly Recommended for implementation, with some Discouragement
+* Mostly Discouraged for implementation, with some Recommendation
+
+For example, the preamble to ECIP 1 might be updated to include the line:
+
+    Comments-Summary: No comments yet.
+    Comments-URI: https://github.com/ethereumproject/ECIPs/wiki/Comments:ECIP-1000
+                  https://some-other-wiki.org/ECIP_1_Comments
+
+These fields must follow the "Discussions-To" header defined in ECIP 1 (if that header is not present, it should follow the position where it would be present; generally this is immediately above the Status header).
+
+To avoid doubt: comments and status are unrelated metrics to judge a ECIP, and neither should be directly influencing the other.
+
+===Rationale===
+
+What is the purpose of ECIP comments?
+
+* Various ECIPs have been adopted (the criteria required for "Final" Status) despite being considered generally inadvisable. Some presently regard ECIPs as a "good idea" simply by virtue of them being assigned a ECIP number. Due to the low barrier of entry for submission of new ECIPs, it seems advisable for a way for reviewers to express their opinions on them in a way that is consumable to the public without needing to review the entire development discussion.
+
+Will ECIP comments be censored or limited to particular participants/"experts"?
+
+* Participants should freely refrain from commenting outside of their area of knowledge or expertise. However, comments should not be censored, and participation should be open to the public.
+
+==ECIP licensing==
+
+===Specification===
+
+New ECIPs may be accepted with the following licenses. Each new ECIP must identify at least one acceptable license in its preamble. The License header in the preamble must be placed after the Created header. Each license must be referenced by their respective abbreviation given below.
+
+For example, a preamble might include the following License header:
+
+    License: BSD-2-Clause
+             GNU-All-Permissive
+
+In this case, the ECIP text is fully licensed under both the OSI-approved BSD 2-clause license as well as the GNU All-Permissive License, and anyone may modify and redistribute the text provided they comply with the terms of *either* license. In other words, the license list is an "OR choice", not an "AND also" requirement.
+
+It is also possible to license source code differently from the ECIP text. A optional License-Code header is placed after the License header. Again, each license must be referenced by their respective abbreviation given below.
+
+For example, a preamble specifying the optional License-Code header might look like:
+
+    License: BSD-2-Clause
+             GNU-All-Permissive
+    License-Code: GPL-2.0+
+
+In this case, the code in the ECIP is not available under the BSD or All-Permissive licenses, but only under the terms of the GNU General Public License (GPL), version 2 or newer.
+If the code were to be available under *only* version 2 exactly, the "+" symbol should be removed from the license abbreviation.
+For a later version (eg, GPL 3.0), you would increase the version number (and retain or remove the "+" depending on intent).
+
+    License-Code: GPL-2.0   # This refers to GPL v2.0 *only*, no later license versions are acceptable.
+    License-Code: GPL-2.0+  # This refers to GPL v2.0 *or later*.
+    License-Code: GPL-3.0   # This refers to GPL v3.0 *only*, no later license versions are acceptable.
+    License-Code: GPL-3.0+  # This refers to GPL v3.0 *or later*.
+
+In the event that the licensing for the text or code is too complicated to express with a simple list of alternatives, the list should instead be replaced with the single term "Complex". In all cases, details of the licensing terms must be provided in the Copyright section of the ECIP.
+
+ECIPs are not required to be *exclusively* licensed under approved terms, and may also be licensed under unacceptable licenses *in addition to* at least one acceptable license.
+In this case, only the acceptable license(s) should be listed in the License and License-Code headers.
+
+====Recommended licenses====
+
+* Apache-2.0: [http://www.apache.org/licenses/LICENSE-2.0 Apache License, version 2.0]
+* BSD-2-Clause: [https://opensource.org/licenses/BSD-2-Clause OSI-approved BSD 2-clause license]
+* BSD-3-Clause: [https://opensource.org/licenses/BSD-3-Clause OSI-approved BSD 3-clause license]
+* CC0-1.0: [https://creativecommons.org/publicdomain/zero/1.0/ Creative Commons CC0 1.0 Universal]
+* GNU-All-Permissive: [http://www.gnu.org/prep/maintain/html_node/License-Notices-for-Other-Files.html GNU All-Permissive License]
+
+In addition, it is recommended that literal code included in the ECIP be dual-licensed under the same license terms as the project it modifies. For example, literal code intended for Ethereum Classic Core would ideally be dual-licensed under the MIT license terms as well as one of the above with the rest of the ECIP text.
+
+====Not recommended, but acceptable licenses====
+
+* BSL-1.0: [http://www.boost.org/LICENSE_1_0.txt Boost Software License, version 1.0]
+* CC-BY-4.0: [https://creativecommons.org/licenses/by/4.0/ Creative Commons Attribution 4.0 International]
+* CC-BY-SA-4.0: [https://creativecommons.org/licenses/by-sa/4.0/ Creative Commons Attribution-ShareAlike 4.0 International]
+* MIT: [https://opensource.org/licenses/MIT Expat/MIT/X11 license]
+* AGPL-3.0+: [http://www.gnu.org/licenses/agpl-3.0.en.html GNU Affero General Public License (AGPL), version 3 or newer]
+* FDL-1.3: [http://www.gnu.org/licenses/fdl-1.3.en.html GNU Free Documentation License, version 1.3]
+* GPL-2.0+: [http://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html GNU General Public License (GPL), version 2 or newer]
+* LGPL-2.1+: [http://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html GNU Lesser General Public License (LGPL), version 2.1 or newer]
+
+===Rationale===
+
+Why are there software licenses included?
+
+* Some ECIPs, especially consensus layer, may include literal code in the ECIP itself which may not be available under the exact license terms of the ECIP.
+* Despite this, not all software licenses would be acceptable for content included in ECIPs.
+
+==See Also==
+
+* [https://tools.ietf.org/html/rfc7282 RFC 7282: On Consensus and Humming in the IETF]
diff --git a/ECIPs/ECIP-1016.md b/ECIPs/ECIP-1016.md
new file mode 100644
index 00000000..6317902a
--- /dev/null
+++ b/ECIPs/ECIP-1016.md
@@ -0,0 +1,23 @@
+### ETC Improvement Proposal Management
+
+    ECIP:  1016
+    Title: ETC Improvement Proposal Management
+    Status: Draft
+    Type: Process
+    Author: Cody W Burns <Cody.w.burns@ethereumclassic.com>
+    Created: 2016-10-25
+
+### Abstract: 
+The Current ECIP process is chaos. ECIPs are created in random number order without adequate means of tracking changes or monitoring status. During the forming phase of ETC this was somewhat acceptable. Moving forward the process needs to be made clearer to facilitate clearer communication to all participants  
+
+### Implementation
+All ETC Improvement Proposal should be submitted as pull requests with the format ECIP-`n` with `n` being the number after the previous ECIP. This allows for change tracking and historical monitoring.
+
+Every ECIP Should be tagged with a milestone for its current status
+`Draft | Active | Accepted | Deferred | Rejected | Withdrawn | Final | Superseded`
+
+Every ECIP Should be tagged with a label for its type and layer:
+`Standards Track | Informational | Process`
+`Consensus | Networking | API/RPC | Applications`
+
+Every ECIP should follow https://github.com/ethereumproject/ECIPs/blob/master/ECIP-0000.md.sample as closely as practical.
diff --git a/ECIPs/ECIP-1018.md b/ECIPs/ECIP-1018.md
new file mode 100644
index 00000000..37e9dc30
--- /dev/null
+++ b/ECIPs/ECIP-1018.md
@@ -0,0 +1,84 @@
+###  Title
+
+    ECIP: 1018
+    Title: (Epoch Decay) Monetary Policy and Final Modification to the Ethereum Classic Emission Schedule
+    Author: Mike Boremi <ecip-1018@mikes.email>
+    Status: Draft
+    Type: Standard
+    Created: 2017/01/19
+
+###  Abstract
+
+This ECIP proposes a solution to the Ethereum Classic Monetary Policy to adjust, with absolute finality, the current emission schedule implementation of 14.0625ETC per block in perpetuity. The solution proposed introduces a hard limit upper bound on the maximum absolute number of ETC and introduces a method of degraded emission over time.  This occurs in such a way there is a constant decay in miner/uncle reward every epoch until reaching 0, where gas fees are the sole source of reward. This proposal does not include any solution to changes in protocol introducing PoS or other block forging scheme.
+
+###  Motivation
+
+At its core, the purpose of adjusting the current monetary policy of the ETC network, to a policy which places a hard limit upper bound on the number of tokens issued and decreases the rate at which ETC is introduced into the system over time, is to "bootstrap" the network’s security. By increasing the security of the network, a proper monetary policy indirectly nurtures the network, providing a secure platform for which smart contract development will be more likely to occur.
+
+If we accept that speculation, a demand function, is the main economic driver of any new system, that the Ethereum Classic Network is a new system, and that speculation will drive the value of the Ethereum Classic token until the utility value of the Ethereum Classic token exceeds its speculative value, it is reasonable to assume that rewarding speculation will help to secure and nurture the network:
+
+Large scale, high risk, and/or high profile applications will be less likely to be developed on a blockchain with weak security ie. a low hashrate. Increasing demand for the Ethereum Classic token will, all else being equal, increase the price of the Ethereum Classic token.  An increase in the price of the token incentivizes mining operations to direct their efforts on the Ethereum Classic Network or to begin operations on the Ethereum Classic Network. The additional mining power that is directed towards the network, because of this incentive, further secures the network. An increase in the security of the network assists in building trust between the network and both current and potential users and developers of the network. This increase of trust in the network provides an incentive for large scale, high risk, and/or high profile applications to be developed on the network. Thus, rewarding speculation helps to secure and nurture the Ethereum Classic network. 
+
+Especially important to early stage cryptocurrencies, assuming all other variables are equal, a network with a decreasing rate of production and an upper bound on the number of tokens that will be issued will provide more incentive for high risk speculation to occur than one without a known rate of production or an upper bound. 
+
+Above all, it is important to recognize that a monetary policy does not directly create value for the network. A stable platform with useful applications and a vibrant community are the variables that drive value. The purpose of a properly structured monetary policy is to create an incentive for people to take a risk on a system that has not yet reached its full potential, providing an additional reason for those who may not otherwise be interested, who cannot or have not developed anything on the platform (yet), or who remain skeptical, to involve themselves in an otherwise nascent platform. 
+
+###  Specification
+
+####  Current Ethereum Classic Monetary Policy
+
+[Source](http://ethdocs.org/en/latest/mining.html)
+
+![image alt text](https://cloud.githubusercontent.com/assets/36461/22116162/e3c0a2f2-de2c-11e6-8ab3-38452b3486bc.png)
+
+The current mining rewards on the Ethereum Classic Network are as follows:
+
+* A "static" block reward for the winning block of 5 ETC
+
+* An extra reward to the winning miner for including uncles as part of the block, in the form of an extra 1/32 (0.15625ETC) per uncle included, up to a maximum of two (2) uncles. 
+
+* A reward of 7/8 (4.375ETC) of the winning block reward for a miner who has mined an uncled block and has that uncle included in the winning block by the winning miner, up to a maximum of two (2) uncles included in a winning block.
+
+* This reward structure is set to continue in perpetuity.
+
+####  Proposed Ethereum Classic Monetary Policy
+
+[Source](https://docs.google.com/spreadsheets/d/1itL2prCC6f5p__RmiU_svWlNkyL0vRdqu8FCz5ca7v0/edit#gid=1694393546)
+
+![image alt text](https://cloud.githubusercontent.com/assets/36461/22131547/65e6f544-de71-11e6-8ab7-2c7a361d19e7.png)
+
+#####  Block Reward Adjustment Period: `1 Epoch (30,000 blocks)`
+
+#####  Reward Decay Starting Block: `5,010,000 (Epoch 167)`
+
+#####  Pre-calculated Decay Options
+
+|Decay Option #|Decay Percentage|Miner Decay Amount|Uncle Decay Amount|Years to Decay|Estimated Supply (Current Reward)|Estimated Supply (1.5% Growth Reward)|Block Height Reward Ends|
+|--------------|----------------|------------------|------------------|--------------|---------------------------------|-------------------------------------|------------------------|
+|1|0.5000%|0.025000|0.002500|5.236872146|130,071,034.98|130,073,443.73|11,010,000|
+|2|0.2500%|0.012500|0.001250|8.090753425|161,716,038.24|161,720,708.59|17,010,000|
+|3|0.1250%|0.006250|0.000625|13.79851598|225,006,044.76|225,018,362.75|29,010,000|
+|4|0.0625%|0.003125|0.0003125|25.2140411|351,586,057.80|351,991,724.60|53,010,000|
+
+###  Rationale
+
+*  Gradual decay of rewards to 0.  Length of time depends on decay rate. 
+*  Dead simple to understand.
+  *  Starting at Epoch 167 (Block # 5,010,000) the decay activates
+  *  Rewards for mining block start at: `5 ETC`
+  *  Rewards for mining uncled start at: `0.5 ETC`
+  *  Decay persists each Epoch until reaching 0, in which gas costs are the only collected fees
+*  Simple, nearly straight line supply growth on chart.  Only fluctuation is gas rewards/uncle rates, as this is not predictable in all long term models.
+*  The Epoch Decay model provides a balance between providing an acceptable depreciating distribution rate for rewarding high risk investment into the system, and maintaining an active supply production over time, maintaining a future supply rate and keeping that potential price of the ethereum token suppressed enough to ensure transaction prices can remain lower than if the supply were to reduce to zero at an earlier date. This serves as a "blow off valve" for price increase in the case that a dynamic gas model cannot be implemented for the foreseeable future. 
+*  Having the monetary policy reward decay begin at block 5,010,000 (Epoch 167) provides a balance between delaying the implementation to provide enough time for code development and testing, and accelerating the implementation to provide an incentive to potential early adopters and high risk investors. Based on community discussion, beginning before block 4,000,000 is too soon for development, testing, and implementation of the policy, and later than block 6,000,000 is too long to interest many potential early adopters/investors. 
+*  Not changing the monetary policy of ETC provides no benefit to risk taking early on in the life of the system, speculation wise. It will be difficult for the network to bootstrap its security. While bitcoin has what is considered to be the generally accepted ideal monetary policy, with its 50% reduction every four years, this model is not likely to yield optimal investment for ETC. If ETC were to adopt the bitcoin halving model, it is arguable that too much of the supply would be produced too soon: 50% of the estimated total ETC supply would be mined 75% sooner than traditional bitcoin because of the pre-mine of 72,002,454.77 ETC that was initially created in the genesis block. While the Epoch Decay model does not completely eliminate the effects of the premine, since 50% of total estimated production occurs sooner than would the bitcoin model, it makes up for this, to an extent, depending on how much decay is decided upon. 
+*  In the current ETC reward schedule, the total reward for uncles is higher than the reward received by the miner who also includes uncles. In this state, a miner is significantly diluting the value of his reward by including these uncled blocks. By equalizing the rewards to uncle block miners with the rewards to miners who include an uncle block, the reward structure is more fairly distributed. In addition, equalizing the uncle rewards reduces the incentive for miners to set up an ETC "uncle farm," and instead drives them to better secure the network by competing for the latest "real block." 
+*  Because the rate at which uncled blocks can vary with extreme, reducing the reward for uncle blocks assists considerably with being able to forecast the true upper bound of the total ETC that will ultimately exist in the system. 
+*  The model is the best attempt at balancing the needs to incentivize high risk investment into the system in order to bootstrap security and create a potential user base, be easy to understand, include a reduction to the rate of production of ETC over time, include an upper bound on supply, and also provide for a long term production of the ETC token.
+
+###  Implementation
+
+*  Timeline for the implementation and the code required to execute after approval.
+
+#####  Shout out to @snaproll for the great ECIP template to use.  Your time on this is greatly appreciated.
+
diff --git a/ECIPs/ECIP-1019.md b/ECIPs/ECIP-1019.md
new file mode 100644
index 00000000..9ad9c94c
--- /dev/null
+++ b/ECIPs/ECIP-1019.md
@@ -0,0 +1,87 @@
+###  Title
+
+    ECIP: 1019
+    Title: (Epoch Decay 10) Monetary Policy and Final Modification to the Ethereum Classic Emission Schedule
+    Author: Mike Boremi <ecip-1019@mikes.email>
+    Status: Draft
+    Type: Standard
+    Created: 2017/01/19
+
+###  Abstract
+
+This ECIP proposes a solution to the Ethereum Classic Monetary Policy to adjust, with absolute finality, the current emission schedule implementation of 14.0625ETC per block in perpetuity. The solution proposed introduces a hard limit upper bound on the maximum absolute number of ETC and introduces a method of degraded emission over time.  This occurs in such a way there is a constant decay in miner/uncle reward every epoch until reaching 0, where gas fees are the sole source of reward. This proposal does not include any solution to changes in protocol introducing PoS or other block forging scheme.
+
+###  Motivation
+
+At its core, the purpose of adjusting the current monetary policy of the ETC network, to a policy which places a hard limit upper bound on the number of tokens issued and decreases the rate at which ETC is introduced into the system over time, is to "bootstrap" the network’s security. By increasing the security of the network, a proper monetary policy indirectly nurtures the network, providing a secure platform for which smart contract development will be more likely to occur.
+
+If we accept that speculation, a demand function, is the main economic driver of any new system, that the Ethereum Classic Network is a new system, and that speculation will drive the value of the Ethereum Classic token until the utility value of the Ethereum Classic token exceeds its speculative value, it is reasonable to assume that rewarding speculation will help to secure and nurture the network:
+
+Large scale, high risk, and/or high profile applications will be less likely to be developed on a blockchain with weak security ie. a low hashrate. Increasing demand for the Ethereum Classic token will, all else being equal, increase the price of the Ethereum Classic token.  An increase in the price of the token incentivizes mining operations to direct their efforts on the Ethereum Classic Network or to begin operations on the Ethereum Classic Network. The additional mining power that is directed towards the network, because of this incentive, further secures the network. An increase in the security of the network assists in building trust between the network and both current and potential users and developers of the network. This increase of trust in the network provides an incentive for large scale, high risk, and/or high profile applications to be developed on the network. Thus, rewarding speculation helps to secure and nurture the Ethereum Classic network. 
+
+Especially important to early stage cryptocurrencies, assuming all other variables are equal, a network with a decreasing rate of production and an upper bound on the number of tokens that will be issued will provide more incentive for high risk speculation to occur than one without a known rate of production or an upper bound. 
+
+Above all, it is important to recognize that a monetary policy does not directly create value for the network. A stable platform with useful applications and a vibrant community are the variables that drive value. The purpose of a properly structured monetary policy is to create an incentive for people to take a risk on a system that has not yet reached its full potential, providing an additional reason for those who may not otherwise be interested, who cannot or have not developed anything on the platform (yet), or who remain skeptical, to involve themselves in an otherwise nascent platform. 
+
+###  Specification
+
+####  Current Ethereum Classic Monetary Policy
+
+[Source](http://ethdocs.org/en/latest/mining.html)
+
+![image alt text](https://cloud.githubusercontent.com/assets/36461/22116162/e3c0a2f2-de2c-11e6-8ab3-38452b3486bc.png)
+
+The current mining rewards on the Ethereum Classic Network are as follows:
+
+* A "static" block reward for the winning block of 5 ETC
+
+* An extra reward to the winning miner for including uncles as part of the block, in the form of an extra 1/32 (0.15625ETC) per uncle included, up to a maximum of two (2) uncles. 
+
+* A reward of 7/8 (4.375ETC) of the winning block reward for a miner who has mined an uncled block and has that uncle included in the winning block by the winning miner, up to a maximum of two (2) uncles included in a winning block.
+
+* This reward structure is set to continue in perpetuity.
+
+####  Proposed Ethereum Classic Monetary Policy
+
+[Source](https://docs.google.com/spreadsheets/d/1mPPfzLtJ5V7mz2gz5hyqTytJSyoQ3oRyvs7CAIoMnH8/edit#gid=1694393546)
+
+![image alt text](https://cloud.githubusercontent.com/assets/36461/22135058/0cf73242-de89-11e6-945e-c1e2cd2105d2.png)
+
+#####  Block Reward Adjustment Period: `10 Epoch (300,000 blocks)`
+
+#####  Reward Decay Starting Block: `5,010,000 (Epoch 167)`
+
+#####  Pre-calculated Decay Options
+
+|Decay Option #|Decay Percentage|Miner Decay Amount|Uncle Decay Amount|Years to Decay|Estimated Supply (Current Reward)|Block Height Reward Ends|
+|--------------|----------------|------------------|------------------|--------------|---------------------------------|------------------------|
+|1|5.00%|0.2500|0.02500|5.236872146|99,851,032|11,010,000|
+|2|4.00%|0.2000|0.02000|5.950342466|100,226,032|12,510,000|
+|3|3.00%|0.1500|0.01500|7.139454909|100,851,532|15,009,990|
+|4|2.00%|0.1000|0.01000|9.517694064|102,101,032|20,010,000|
+|5|1.00%|0.0500|0.00500|16.65239726|105,851,032|35,010,000|
+|6|0.50%|0.0250|0.00250|30.92180365|113,351,032|65,010,000|
+|7|0.25%|0.0125|0.00125|59.46061644|128,351,032|125,010,000|
+
+###  Rationale
+
+-  Gradual decay of rewards to 0.  Length of time depends on decay rate. 
+-  Dead simple to understand.
+   -  Starting at Epoch 167 (Block # 5,010,000) the decay activates
+   -  Rewards for mining block start at: `5 ETC`
+   -  Rewards for mining uncled start at: `0.5 ETC`
+   -  Decay persists every 10 Epoch until reaching 0, in which gas costs are the only collected fees
+-  Simple, nearly straight line supply growth on chart.  Only fluctuation is gas rewards/uncle rates, as this is not predictable in all long term models.
+-  The Epoch Decay model provides a balance between providing an acceptable depreciating distribution rate for rewarding high risk investment into the system, and maintaining an active supply production over time, maintaining a future supply rate and keeping that potential price of the ethereum token suppressed enough to ensure transaction prices can remain lower than if the supply were to reduce to zero at an earlier date. This serves as a "blow off valve" for price increase in the case that a dynamic gas model cannot be implemented for the foreseeable future. 
+-  Having the monetary policy reward decay begin at block 5,010,000 (Epoch 167) provides a balance between delaying the implementation to provide enough time for code development and testing, and accelerating the implementation to provide an incentive to potential early adopters and high risk investors. Based on community discussion, beginning before block 4,000,000 is too soon for development, testing, and implementation of the policy, and later than block 6,000,000 is too long to interest many potential early adopters/investors. 
+-  Not changing the monetary policy of ETC provides no benefit to risk taking early on in the life of the system, speculation wise. It will be difficult for the network to bootstrap its security. While bitcoin has what is considered to be the generally accepted ideal monetary policy, with its 50% reduction every four years, this model is not likely to yield optimal investment for ETC. If ETC were to adopt the bitcoin halving model, it is arguable that too much of the supply would be produced too soon: 50% of the estimated total ETC supply would be mined 75% sooner than traditional bitcoin because of the pre-mine of 72,002,454.77 ETC that was initially created in the genesis block. While the Epoch Decay model does not completely eliminate the effects of the premine, since 50% of total estimated production occurs sooner than would the bitcoin model, it makes up for this, to an extent, depending on how much decay is decided upon. 
+-  In the current ETC reward schedule, the total reward for uncles is higher than the reward received by the miner who also includes uncles. In this state, a miner is significantly diluting the value of his reward by including these uncled blocks. By equalizing the rewards to uncle block miners with the rewards to miners who include an uncle block, the reward structure is more fairly distributed. In addition, equalizing the uncle rewards reduces the incentive for miners to set up an ETC "uncle farm," and instead drives them to better secure the network by competing for the latest "real block." 
+-  Because the rate at which uncled blocks can vary with extreme, reducing the reward for uncle blocks assists considerably with being able to forecast the true upper bound of the total ETC that will ultimately exist in the system. 
+-  The model is the best attempt at balancing the needs to incentivize high risk investment into the system in order to bootstrap security and create a potential user base, be easy to understand, include a reduction to the rate of production of ETC over time, include an upper bound on supply, and also provide for a long term production of the ETC token.
+
+###  Implementation
+
+*  Timeline for the implementation and the code required to execute after approval.
+
+#####  Shout out to @snaproll for the great ECIP template to use.  Your time on this is greatly appreciated.
+
diff --git a/ECIPs/ECIP-1022.md b/ECIPs/ECIP-1022.md
new file mode 100644
index 00000000..55e341f5
--- /dev/null
+++ b/ECIPs/ECIP-1022.md
@@ -0,0 +1,189 @@
+## Title
+
+    ECIP: 1022
+    Title: Generalized Version Bits Voting for Consensus Soft and Hard Forks
+    Author: Wei Tang <hi@that.world>
+    Status: Draft
+    Type: Informational
+    Created: 2017/06/28
+    
+<br />
+
+## Abstract
+
+The following ECIP tries to bring the best practices about how Bitcoin deals with consensus hard fork ([BIP-9](https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki) and [BIP-135](https://github.com/bitcoin/bips/blob/master/bip-0135.mediawiki)) into Ethereum Classic. Rather than hard-code a block number as we currently do, each block mined emits support of the new consensus hard-fork. Only when a large enough portion of the network support it, the hard-fork is "locked-in" and will be activated.
+
+## Motivation
+
+**Lack of an appropriate voting method can results in network forking**. The DAO hard fork was such an example. Currently the way Ethereum used to gather opinions was through [CarbonVote](http://carbonvote.com/). It indeed has the advantage that it brings the opinions of Ethereum holders rather than miners. However, it is not enforceable and we all know the disastrous result it brought during the DAO hard fork period. We don't want that to happen again.
+
+**Miner community, stake holders and proof of work**. It is common knowledge that Ethereum Classic will probably stay in proof of work, rather than, like Ethereum, switch to a proof of stake algorithm. Combining this ECIP together with ECIP-1023, we combines opinions from both the miner community and ETC coin holders to reach consensus about whether a hard fork should occur.
+
+**Best practices from Bitcoin**. [BIP-9](https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki), which uses version bits mined in each blocks to vote for consensus soft fork has be successfully conducted for several. Its upgraded version, BIP-135, aims to deal with both soft forks and hard forks alike.
+
+**Potentially faster adoption of new consensus hard fork**. When dealing with emergency consensus hard fork for preventing network attacks, the developer would not need to artificially insert a "hard fork block number" (which must leave enough time for everyone else to upgrade their clients, and then wait for that block). The ETC coin holders and miners collectively decide when the hard fork happens, which potentially could be faster than hard coded block numbers.
+
+**Ethereum Classic will become a stable protocol soon**. When we finished dealing with the monetary policy and finally the difficulty bomb, ETC's protocol would become a rather stable one. This means most of the new consensus hard fork would be new features of the network, rather than fixing existing bugs. In that case, voting would be important to keep the whole network healthy.
+
+## Terms and conventions
+
+The version bits used by this proposal for signaling deployment of forks are
+referred to as 'signaling bits' or shortened to 'bits' where unambiguous.
+
+The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
+"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
+document are to be interpreted as described in RFC 2119.
+
+## Specification
+
+### Signaling bits
+
+Ethereum's extraData field are 32-bytes, i.e. a 256-bit value. The field itself should be a RLP list that follows:
+
+```
+[ version: P, signalingBits: S, clientIdentity: B ]
+```
+
+For this ECIP, `version` should equal to `1`, and `signalingBits` and `clientIdentity` fulfill the rest of the extraData field as long as it does not exceed the maximum size allowed. This allows us to have way more concurrent signalings and better backward compatibility than Bitcoin.
+
+`signalingBits` are right-aligned, i.e. `0b1` has its bit at index 0 set, `0b10` has its bit at index 1 set, `0b100` has its bit at index 2 set.
+
+### Deployment states
+
+With each block and fork, we associate a deployment state. The possible states are:
+
+* **DEFINED** is the first state that each fork starts out as. The genesis block for any chain SHALL by definition be in this state for each deployment.
+* **STARTED** for blocks past the starttime.
+* **LOCKED_IN** after STARTED, if at least threshold out of windowsize blocks have the associated bit set in `signalingBits` in `extraData` block header, measured at next height that is evenly divisible by the windowsize.
+* **ACTIVE** for all blocks after the grace period conditions have been met.
+* **FAILED** if past the timeout time and LOCKED_IN was not reached.
+
+In accordance with BIP9, a block's state SHALL never depend on its own extraData; only on that of its ancestors.
+
+### Fork deployment parameters
+
+Each fork deployment is specified by the following per-chain parameters:
+
+* The **name** specifies a very brief description of the fork, reasonable for use as an identifier. For deployments described in a single BIP, it is recommended to use the name "bipN" where N is the appropriate BIP number.
+* The **bit** determines which bit in the extraData field of the block is to be used to signal the fork deployment.
+* The **start** specifies a block number at which the bit gains its meaning.
+* The **timeout** specifies a time at which the deployment is considered failed. If the current block number >= (start + timeout) and the fork has not yet locked in (including this block's bit state), the deployment is considered failed on all descendants of the block.
+* The **windowsize** specifies the number of past blocks (including the block under consideration) to be taken into account for locking in a fork.
+* The **threshold** specifies a number of blocks, in the range of 1..windowsize, which must signal for a fork in order to lock it in. The support is measured when the chain height is evenly divisible by the windowsize. If the windowsize is set to 2016 (as in BIP9) this coincides with the 2016-block re-targeting intervals.
+* The **minlockedblocks** specifies a minimum number of blocks which a fork must remain in locked-in state before it can become active. Both minlockedblocks and minlockedtime (see below) must be satisfied before a fork can become active. If the current block number >= (minlockedblocks + the block number that locked in the fork), then the fork becomes activated. 
+
+### Tallying
+
+If a block's extraData specifies a version other than `1`, all its signaling bits MUST be treated as if they are '0'.
+
+A signaling bit value of '1' SHALL indicate support of a fork and SHALL count towards its tally on a chain.
+
+A signaling bit value of '0' SHALL indicate absence of support of a fork and SHALL NOT count towards its tally on a chain.
+
+The signaling bits SHALL be tallied whenever the head of the active chain changes (including after reorganizations).
+
+### State transitions
+
+The following diagram illustrates the generalized state machine:
+
+![State transactions](ECIP-1022/bip-0135-states-small.png)
+
+The genesis block of any chain SHALL have the state DEFINED for each deployment.
+
+A given deployment SHALL remain in the DEFINED state until it either passes the start (and becomes STARTED) or the timeout time (and becomes FAILED).
+
+Once a deployment has STARTED, the signal for that deployment SHALL be tallied over the the past windowsize blocks whenever a new block is received on that chain.
+
+A transition from the STARTED state to the LOCKED_IN state SHALL only occur when all of these are true:
+
+* the height of the received block is an integer multiple of the window size
+* the current block number is below (start + timeout)
+* at least threshold out of windowsize blocks have signaled support
+
+A similar height synchronization precondition SHALL exist for the transition from LOCKED_IN to ACTIVE. These synchronization conditions are expressed by the "mod(height, windowsize) = 0" clauses in the diagram.
+
+A transition from LOCKED_IN to ACTIVE state SHALL only occur if the height synchronization criterion is met and the below configurable 'grace period' conditions are fulfilled:
+
+* current height MUST be at least minlockedblocks above LOCKED_IN height
+
+NOTE: If minlockedblocks is set to 0, then the fork will proceed directly to ACTIVE state once the chain height reaches a multiple of the windowsize.
+
+The ACTIVE and FAILED states are terminal; a deployment stays in these states once they are reached.
+
+Deployment states are maintained along block chain branches. They need re-computation when a reorganization happens.
+
+### New consensus rules
+
+New consensus rules deployed by a fork SHALL be enforced for each block that has ACTIVE state.
+
+### Optional operator notifications
+
+An implementation SHOULD notify the operator when a deployment transitions
+to STARTED, LOCKED_IN, ACTIVE or FAILED states.
+
+It is RECOMMENDED that an implementation provide finer-grained notifications
+to the operator which allow him/her to track the measured support level for
+defined deployments.
+
+An implementation SHOULD warn the operator if the configured (emitted) nVersion
+has been overridden to contain bits set to '1' in contravention of the above
+non-signaling recommendations for DEFINED forks.
+
+It is RECOMMENDED that an implementation warn the operator if no signal has
+been received for a given deployment during a full windowsize period after the
+deployment has STARTED. This could indicate that something may be wrong with
+the operator's configuration that is causing them not to receive the signal
+correctly.
+
+For undefined signals, it is RECOMMENDED that implementation track these and
+alert their operators with supportive upgrade notifications, e.g.
+
+* "warning: signaling started on unknown feature on version bit X"
+* "warning: signaling on unknown feature reached X% (over last N blocks)"
+* "info: signaling ceased on unknown feature (over last M blocks)"
+
+Since parameters of these deployments are unknown, it is RECOMMENDED that
+implementations allow the user to configure the emission of such notifications
+(e.g. suitable N and M parameters in the messages above, e.g. a best-guess
+window of 100 blocks).
+
+## Rationale
+
+The timeout into FAILED state allows eventual reuse of bits if a fork was not successfully activated.
+
+A fallow period at the conclusion of a fork attempt allows some detection of buggy clients, and allows time for warnings and software upgrades for successful forks. The duration of a fallow period is not specified by this proposal, although a conventional fallow period of 3 months is RECOMMENDED.
+
+## Guidelines
+
+### Parameter selection guidelines
+
+The following guidelines are suggested for selecting the parameters for a fork:
+
+* **name** SHOULD be selected such that no two forks, concurrent or otherwise, ever use the same name.
+* **bit** SHOULD be selected such that no two concurrent forks use the same bit. Implementors should make an effort to consult resources such as [2] to establish whether the bit they wish to use can reasonably be assumed to be unclaimed by a concurrent fork, and to announce their use ('claim') of a bit for a fork purpose on various project mailing lists, to reduce chance of collisions.
+* **start** SHOULD be set to some block number in the future, approximately one month after a software release date which includes the fork signaling.  This allows for some release delays, while preventing triggers as a result of parties running pre-release software.
+* **timeout** is RECOMMENDED to be a block number that is approximately 1 year after start.
+* **windowsize** SHOULD be set large enough to allow reception of an adequately precise signal.
+* **threshold** SHOULD be set as high as possible to ensure a smooth activation based on the estimated support and the nature of the proposed changes. It is strongly RECOMMENDED that threshold >= windowsize / 2 (rounded up) to ensure that a proposal is only activated by majority support.
+* **minlockedblocks** is RECOMMENDED to be set >= windowsize, to ensure that a full window passes in LOCKED_IN state. Lower values will be ineffective as the transition from LOCKED_IN to ACTIVE is guarded by a synchronization based on the window size.
+
+NOTE: If minlockedblocks is set to 0, then the fork will proceed to ACTIVE state when the chain height reaches a multiple of the windowsize.
+
+A later deployment using the same bit is possible as long as the starttime is after the previous fork's timeout or activation, but it is discouraged until necessary, and even then recommended to have a pause in between to detect buggy software.
+
+### Signaling guidelines
+
+An implementation SHOULD signal '0' on a bit if one of the following holds true:
+
+* the deployment parameters are not DEFINED (not configured or explicitly undefined)
+* the deployment is DEFINED and has not yet reached the STARTED state
+* the deployment has succeeded (it has become ACTIVE)
+* the deployment has FAILED
+
+An implementation SHOULD enable the operator to choose (override) whether to signal '0' or '1' on a bit, once its deployment has at least reached the STARTED state.
+
+A supporting miner SHOULD signal '1' on a bit for which the deployment is LOCKED_IN state so that uptake is visible. However, this has no effect on consensus rules. Once LOCKED_IN, a deployment proceeds to ACTIVE solely based on the configured grace period parameters (see 'Fork deployment parameters' above).
+
+A miner SHOULD signal '0' on a bit if they wish to suspend signaling of support for a fork that is DEFINED in their software.
+
+It is NOT RECOMMENDED to signal '1' for bits where the meaning is undefined (i.e. bits which are unclaimed by proposals).
diff --git a/ECIPs/ECIP-1023.md b/ECIPs/ECIP-1023.md
new file mode 100644
index 00000000..f382aed6
--- /dev/null
+++ b/ECIPs/ECIP-1023.md
@@ -0,0 +1,66 @@
+## Title
+
+    ECIP: 1023
+    Title: Combined CarbonVote and MinerVote for Consensus Soft and Hard Forks
+    Author: Wei Tang <hi@that.world>
+    Status: Draft
+    Type: Informational
+    Created: 2017/06/28
+    
+## Abstract
+
+The following ECIP tries to combine a enforced version of Ethereum CarbonVote and the best practices about how Bitcoin deals with consensus hard fork ([BIP-9](https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki) and [BIP-135](https://github.com/bitcoin/bips/blob/master/bip-0135.mediawiki)) into Ethereum Classic using smart contracts. Rather than hard-code a block number as we currently do, each miner and ETC coin holders emits support of the new consensus hard-fork. Only when a large enough portion of the network support it, the hard-fork is "locked-in" and will be activated.
+
+This should be used in combination with ECIP-1022 for its best effect.
+
+## Motivation
+
+In addition to the motivation provided in ECIP-1022:
+
+**ETC coin holders are important**. Holders of coins should also have sayings about whether a hard fork should occur. CarbonVote, if it can be enforced, is a good way to do this.
+
+**Minimal cost for miners to emit support**. The cost for miners to emit support should be minimal.
+
+## Specification
+
+### Fork deployment parameters
+
+In addition to the fork deployment parameters defined in ECIP-1022, the following should also exist:
+
+* **carbonVoteYesAddress** the address for carbon vote YES.
+* **carbonVoteNoAddress** the address for carbon vote NO.
+* **carbonThreshold** specifies the portion * 1000 required, in the entire start..(start + timeout) blocks, which should vote YES.
+
+### Carbon Vote
+
+Besides defining the signaling bits for miners to vote, the implementor of the hard fork should also deploy two new smart contracts (YES and NO) to the ETC network with the code below:
+
+```
+contract Vote {
+    event LogVote(address indexed addr);
+
+    function() {    
+        LogVote(msg.sender);
+
+        if (msg.value > 0) {
+            msg.sender.send(msg.value);
+        }
+    }
+}
+```
+
+ETC holders can vote YES and NO by sending a zero value transaction to any of those contracts.
+
+### Miner vote
+
+The miner will use the voting method defined in ECIP-1022 to conduct the voting.
+
+### Deployment states
+
+To make the voting pass (i.e. status changing from **STARTED** to **LOCKED_IN**), at each voting window, besides requiring the threshold out of windowsize blocks to have the associated bit set in `signalingBits` in `extraData` block header, it also requires the portion of ETC coins that voted YES in the Carbon Vote smart contracts >= (carbonThreshold / 1000000).
+
+Before implementing a hard fork, the implementor should deploy a smart contract for voting (referred to as *The Contract*) to the ETC network that has the following properties.
+
+## Rationale
+
+Miners continue to use `signalingBits` in the `extraData` field to vote, as this is the way with minimal cost for them (and also does not require any protocol change). The consensus is reached jointly by miners and coin holders for a hard fork to pass.
diff --git a/ECIPs/ECIP-1024.md b/ECIPs/ECIP-1024.md
new file mode 100644
index 00000000..5bf56c3d
--- /dev/null
+++ b/ECIPs/ECIP-1024.md
@@ -0,0 +1,107 @@
+## Title
+
+    ECIP: 1024
+    Title: A CarbonVote and MinerVote Contract for Consensus Soft and Hard Forks
+    Author: Wei Tang <hi@that.world>
+    Status: Draft
+    Type: Informational
+    Created: 2017/06/28
+    
+## Abstract
+
+This contract provides a way to implement CarbonVote and MinerVote based **solely** on smart contract, unlike ECIP-1022 and ECIP-1023 which needs to use `extraData` block header. It also provides an interface that voting hard fork smart contracts should follow.
+
+## Motivation
+
+See ECIP-1022 and ECIP-1023 for the motivations.
+
+## Specification
+
+### Deployment states
+
+All hard fork voting smart contract should be in any of the five states below:
+
+* **DEFINED** is the first state that each fork starts out as. The genesis block for any chain SHALL by definition be in this state for each deployment.
+* **STARTED** for blocks past the starttime.
+* **LOCKED_IN** after voting.
+* **ACTIVE** for all blocks after the grace period conditions have been met.
+* **FAILED** if past the timeout time and LOCKED_IN was not reached.
+
+The smart contract should have an `deploymentState()` function that allows querying the current state of this hard fork.
+ 
+## An Implementation
+
+The above defines the interface for hard fork voting smart contracts. Below we provides a possible implementation (persedu-code) as one way to implement the above interface. Note that here for simplicity, we only have one window for the entire miner vote period, and the threshold for both miners and coin holders are set to 95%.
+
+```
+contract Vote {
+  address[] carbonYesAddresses;
+  address[] carbonNoAddresses;
+  uint minerYesCount;
+  
+  string name;
+  uint startBlock;
+  uint timeoutNumber;
+  uint lockedInNumber;
+  enum State { Defined, Started, LockedIn, Active, Failed }
+  
+  function Vote(string n, uint s, uint t, uint l) {
+    startBlock = s;
+    timeoutNumber = t;
+    lockedInNumber = t;
+    name = n;
+  }
+  
+  function carbonYes() {
+    if (block.number < startBlock || block.number > startBlock + timeoutNumber) {
+      throw;
+    }
+    carbonYesAddresses.push(msg.sender);
+  }
+  
+  function carbonNo() {
+    if (block.number < startBlock || block.number > startBlock + timeoutNumber) {
+      throw;
+    }
+    carbonNoAddresses.push(msg.sender);
+  }
+  
+  function minerYes() {
+    if (block.number < startBlock || block.number > startBlock + timeoutNumber) {
+      throw;
+    }
+    if (block.coinbase != msg.sender) {
+      throw;
+    }
+    minerYesCount = minerYesCount + 1;
+  }
+  
+  function passed() {
+    if (block.number < startBlock) {
+      throw;
+    }
+    
+    // If we get 95% of the minerVote and 95% of the carbonVote, it is considered passed.
+    bool passed = true;
+    if (minerYesCount * 100 / min(timeoutNumber, block.number - startBlock) < 95) {
+      passed = false;
+    }
+    uint carbonYesCount = 0;
+    uint carbonNoCount = 0;
+    for (uint i = 0; i < carbonYesAddresses.length; i++) {
+      carbonYesCount += carbonYesAddresses[i].balance;
+    }
+    for (uint i = 0; i < carbonNoAddresses.length; i++) {
+      carbonNoCount += carbonNoAddresses[i].balance;
+    }
+    if (carbonYesCount * 100 / (carbonYesCount + carbonNoCount) < 95) {
+      passed = false;
+    }
+    return passed;
+  }
+  
+  function deploymentState() {
+    // .. use the above passed function to implement this. The details are ignored here.
+  }
+}
+```
\ No newline at end of file
diff --git a/ECIPs/ECIP-1025.md b/ECIPs/ECIP-1025.md
new file mode 100644
index 00000000..bac9b748
--- /dev/null
+++ b/ECIPs/ECIP-1025.md
@@ -0,0 +1,168 @@
+## Title
+
+    ECIP: 1025
+    Title: Precompiled Contracts for zkSNARK Verification
+    Author: Wei Tang <hi@that.world>
+    Status: Draft
+    Type: Consensus (hard-fork)
+    Created: 2017/06/29
+
+<br />
+
+## Motivation
+
+Precompiled contracts for elliptic curve and pairing operations are required in order to perform zkSNARK verification within the block gas limit.
+
+## Abstract
+
+zkSNARK verification will allow anonymous transaction to be executed on the Ethereum Classic network. See [this](https://github.com/zcash/babyzoe/blob/master/zoe/contract/mixer.sol) for how a simple mixer contract can be implemented using zkSNARK verification. This ECIP implements three primitive operations in order to perform zkSNARK verification. This allows changes of zkSNARK algorithms without requiring another hard fork.
+
+The general benefit of zkSNARKs for Ethereum and Ethereum Classic is that it will increase the privacy for users (because of the Zero-Knowledge property) and might also be a scalability solution (because of the succinctness and efficient verifiability property).
+
+This combines [EIP-212](https://github.com/ethereum/EIPs/pull/212) and [EIP-213](https://github.com/ethereum/EIPs/pull/213).
+
+## Specification for Addition and Scalar Multiplication on the Elliptic Curve alt_bn128
+
+Add precompiled contracts for point addition (ADD)  and scalar multiplication (MUL) on the elliptic curve "alt_bn128".
+
+Address of ADD: 0x6
+Address for MUL: 0x7
+
+The curve is defined by:
+```
+Y^2 = X^3 + 3
+over the field F_p with
+p = 21888242871839275222246405745257275088696311157297823662689037894645226208583
+```
+
+### Encoding
+
+Field elements and scalars are encoded as 32 byte big-endian numbers. Curve points are encoded as two field elements `(x, y)`, where the point at infinity is encoded as `(0, 0)`.
+
+Tuples of objects are encoded as their concatenation.
+
+For both precompiled contracts, if the input is shorter than expected, it is assumed to be virtually padded with zeros at the end (i.e. compatible with the semantics of the `CALLDATALOAD` opcode). If the input is longer than expected, surplus bytes at the end are ignored.
+
+The length of the returned data is always as specified (i.e. it is not "unpadded"). 
+
+### Exact semantics
+
+Invalid input: For both contracts, if any input point does not lie on the curve or any of the field elements (point coordinates) is equal or larger than the field modulus p, the contract fails. The scalar can be any number between `0` and `2**256-1`.
+
+#### ADD
+Input: two curve points `(x, y)`.
+Output: curve point `x + y`, where `+` is point addition on the elliptic curve `alt_bn128` specified above.
+Fails on invalid input and consumes all gas provided.
+
+#### MUL
+Input: curve point and scalar `(x, s)`.
+Output: curve point `s * x`, where `*` is the scalar multiplication on the elliptic curve `alt_bn128` specified above.
+Fails on invalid input and consumes all gas.
+
+### Gas costs
+
+To be determined.
+
+### Specification for Optimal Ate Pairing Check on the Elliptic Curve alt_bn128
+
+Add a precompiled contracts for a bilinear function on groups on the elliptic curve "alt_bn128". We will define the precompiled contract in terms of a discrete logarithm. The discrete logarithm is of course assumed to be hard to compute, but we will give an equivalent specification that makes use of elliptic curve pairing functions which can be efficiently computed below.
+
+Address: 0x8
+
+For a cyclic group `G` (written additively) of prime order q let `log_P: G -> F_q` be the discrete logarithm on this group with respect to a generator `P`, i.e. `log_P(x)` is the integer `n` such that `n * P = x`.
+
+The precompiled contract is defined as follows, where the two groups `G_1` and `G_2` and their generators `P_1` and `P_2` are defined below (they have the same order `q`):
+
+```
+Input: (a1, b1, a2, b2, ..., ak, bk) from (G_1 x G_2)^k
+Output: If the length of the input is incorrect or any of the inputs are not elements of
+        the respective group or are not encoded correctly, the call fails.
+        Otherwise, return one if
+        log_P1(a1) * log_P2(b1) + ... + log_P1(ak) * log_P2(bk) = 0
+        (in F_q) and zero else.
+```
+
+Note that `k` is determined from the length of the input. `k == 0` is valid and results in returning one.
+
+In order to check that an input is an element of `G_1`, verifying the encoding of the coordinates and checking that they satisfy the curve equation (or is the encoding of infinity) is sufficient. For `G_2`, in addition to that, the order of the element has to be checked to be equal to the group order `q = 21888242871839275222246405745257275088548364400416034343698204186575808495617`.
+
+### Definition of the groups
+
+The groups `G_1` and `G_2` are cyclic groups of prime order `q = 21888242871839275222246405745257275088548364400416034343698204186575808495617` on the elliptic curve `alt_bn128` defined by the curve equation
+`Y^2 = X^3 + 3`.
+
+The group `G_1` is a cyclic group on the above curve over the field `F_p` with `p = 21888242871839275222246405745257275088696311157297823662689037894645226208583` with generator `P1 = (1, 2)`.
+
+The group `G_2` is a cyclic group on the same elliptic curve over a different field `F_p^2 = F_p[i] / (i^2 + 1)` (p is the same as above) with generator
+```
+P2 = (
+  11559732032986387107991004021392285783925812861821192530917403151452391805634 * i +
+  10857046999023057135944570762232829481370756359578518086990519993285655852781,
+  4082367875863433681332203403145435568316851327593401208105741076214120093531 * i +
+  8495653923123431417604973247489272438418190587263600148770280649306958101930
+)
+```
+
+
+### Encoding
+
+Elements of `F_p` are encoded as 32 byte big-endian numbers. An encoding value of `p` or larger is invalid.
+
+Elements `a * i + b` of `F_p^2` are encoded as two elements of `F_p`, `(a, b)`.
+
+Elliptic curve points are encoded as a Jacobian pair `(X, Y)` where the point at infinity is encoded as `(0, 0)`.
+
+Note that the number `k` is derived from the input length.
+
+The length of the returned data is always exactly 32 bytes and encoded as a 32 byte big-endian number. 
+
+### Gas costs
+
+[Benchmarks run on cpp-ethereum](https://gist.github.com/chriseth/4168b56bfe638cae8da1945dd988600b)
+
+suggest the following gas formula:
+
+`60000 * k + 40000`
+
+if we target 20000 gas per millisecond.
+
+Awaiting benchmarks from other implementations.
+
+## Rationale
+
+The specific curve `alt_bn128` was chosen because it is particularly well-suited for zkSNARKs, or, more specifically their verification building block of pairing functions. Furthermore, by choosing this curve, we can use synergy effects with ZCash and re-use some of their components and artifacts.
+
+The feature of adding curve and field parameters to the inputs was considered but ultimately rejected since it complicates the specification: The gas costs are much harder to determine and it would be possible to call the contracts on something which is not an actual elliptic curve.
+
+A non-compact point encoding was chosen since it still allows to perform some operations in the smart contract itself (inclusion of the full y coordinate) and two encoded points can be compared for equality (no third projective coordinate).
+
+## Backwards Compatibility
+
+As with the introduction of any precompiled contract, contracts that already use the given addresses will change their semantics. Because of that, the addresses are taken from the "reserved range" below 256.
+
+## Implementation
+
+### Optional Ate Pairing Check
+
+The precompiled contract can be implemented using elliptic curve pairing functions, more specifically, an optimal ate pairing on the alt_bn128 curve, which can be implemented efficiently. In order to see that, first note that a pairing function `e: G_1 x G_2 -> G_T` fulfills the following properties (`G_1` and `G_2` are written additively, `G_T` is written multiplicatively):
+
+(1) `e(m * P1, n * P2) = e(P1, P2)^(m * n)`
+(2) `e` is non-degenerate
+
+Now observe that
+```
+log_P1(a1) * log_P2(b1) + ... + log_P1(ak) * log_P2(bk) = 0
+```
+if and only if
+```
+e(P1, P2)^(log_P1(a1) * log_P2(b1) + ... + log_P1(ak) * log_P2(bk)) = e(P1, P2)
+```
+
+Furthermore, the left hand side of this equation is equal to
+```
+e(log_P1(a1) * P1, log_P2(b1) * P2) * ... * e(log_P1(ak) * P1, log_P2(bk) * P2)
+= e(a1, b1) * ... * e(ak, bk)
+```
+
+And thus, the precompiled contract can be implemented by verifying that
+`e(a1, b1) * ... * e(ak, bk) = e(P1, P2)`
diff --git a/ECIPs/ECIP-1026.md b/ECIPs/ECIP-1026.md
new file mode 100644
index 00000000..657002d5
--- /dev/null
+++ b/ECIPs/ECIP-1026.md
@@ -0,0 +1,92 @@
+## Title
+
+    ECIP: 1026
+    Title: Modexp Precompiled Contract
+    Author: Wei Tang <hi@that.world>
+    Status: Draft
+    Type: Consensus (hard-fork)
+    Created: 2017/06/28
+    
+## Rationale
+
+This allows for efficient RSA verification inside of the EVM, as well as other forms of number theory-based cryptography. Note that adding precompiles for addition and subtraction is not required, as the in-EVM algorithm is efficient enough, and multiplication can be done through this precompile via `a * b = ((a + b)**2 - (a - b)**2) / 4`.
+
+The bit-based exponent calculation is done specifically to fairly charge for the often-used exponents of 2 (for multiplication) and 3 and 65537 (for RSA verification).
+
+## Specification
+
+### Parameters
+
+* `GQUADDIVISOR: 100`
+
+### Algorithm
+
+At address 0x00......05, add a precompile that expects input in the following format:
+
+    <length_of_BASE> <length_of_EXPONENT> <length_of_MODULUS> <BASE> <EXPONENT> <MODULUS>
+    
+Where every length is a 32-byte left-padded integer representing the number of bytes to be taken up by the next value. Call data is assumed to be infinitely right-padded with zero bytes, and excess data is ignored. Consumes `floor(max(length_of_MODULUS, length_of_BASE) ** 2 * max(ADJUSTED_EXPONENT_LENGTH, 1) / GQUADDIVISOR)` gas, and if there is enough gas, returns an output `(BASE**EXPONENT) % MODULUS` as a byte array with the same length as the modulus.
+
+`ADJUSTED_EXPONENT_LENGTH` is defined as follows.
+
+* If `length_of_EXPONENT <= 32`, and all bits in `EXPONENT` are 0, return 0
+* If `length_of_EXPONENT <= 32`, then return the index of the highest bit in `EXPONENT` (eg. 1 -> 0, 2 -> 1, 3 -> 1, 255 -> 7, 256 -> 8).
+* If `length_of_EXPONENT > 32`, then return `8 * (length_of_EXPONENT - 32)` plus the index of the highest bit in the first 32 bytes of `EXPONENT` (eg. if `EXPONENT = \x00\x00\x01\x00.....\x00`, with one hundred bytes, then the result is 8 * (100 - 32) + 253 = 797). If all of the first 32 bytes of `EXPONENT` are zero, return exactly `8 * (length_of_EXPONENT - 32)`.
+
+For example, the input data:
+
+    0000000000000000000000000000000000000000000000000000000000000001
+    0000000000000000000000000000000000000000000000000000000000000020
+    0000000000000000000000000000000000000000000000000000000000000020
+    03
+    fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2e
+    fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f
+    
+Represents the exponent `3**(2**256 - 2**32 - 978) % (2**256 - 2**32 - 977)`. By Fermat's little theorem, this equals 1, so the result is:
+
+    0000000000000000000000000000000000000000000000000000000000000001
+    
+Returned as 32 bytes because the modulus length was 32 bytes. The `ADJUSTED_EXPONENT_LENGTH` would be 255, and the gas cost would be `32**2 * 255 / 100 = 2611` gas (note that this is ~five thirds of the cost of using the EXP opcode to compute a 32-byte exponent). A 4096-bit RSA exponentiation would cost `512**2 * 4095 / 100 = 10734796` gas in the worst case, though RSA verification in practice usually uses an exponent of 3 or 65537, which would reduce the gas consumption to 2621 or 41943, respectively.
+
+This input data:
+
+    0000000000000000000000000000000000000000000000000000000000000000
+    0000000000000000000000000000000000000000000000000000000000000020
+    0000000000000000000000000000000000000000000000000000000000000020
+    fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2e
+    fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f
+    
+Would be parsed as a base of 0, exponent of `2**256 - 2**32 - 978` and modulus of `2**256 - 2**32 - 978`, and so would return 0. Notice how if the length_of_BASE is 0, then it does not interpret _any_ data as the base, instead immediately interpreting the next 32 bytes as length_of_EXPONENT.
+
+This input data:
+
+    0000000000000000000000000000000000000000000000000000000000000000
+    0000000000000000000000000000000000000000000000000000000000000020
+    ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
+    fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe
+    fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd
+    
+Would parse a base length of 0, a modulus length of 32, and an exponent length of `2**256 - 1`, where the base is empty, the modulus is `2**256 - 2` and the exponent is `(2**256 - 3) * 256**(2**256 - 33)` (yes, that's a really big number). It would then immediately fail, as it's not possible to provide enough gas to make that computation.
+
+This input data:
+
+    0000000000000000000000000000000000000000000000000000000000000001
+    0000000000000000000000000000000000000000000000000000000000000002
+    0000000000000000000000000000000000000000000000000000000000000020
+    03
+    ffff
+    8000000000000000000000000000000000000000000000000000000000000000
+    07
+
+Would parse as a base of 3, an exponent of 65535, and a modulus of `2**255`, and it would ignore the remaining 0x07 byte.
+
+This input data:
+
+    0000000000000000000000000000000000000000000000000000000000000001
+    0000000000000000000000000000000000000000000000000000000000000002
+    0000000000000000000000000000000000000000000000000000000000000020
+    03
+    ffff
+    80
+    
+Would also parse as a base of 3, an exponent of 65535 and a modulus of `2**255`, as it attempts to grab 32 bytes for the modulus starting from 0x80, but then there is no further data so it right pads it with 31 zeroes.
\ No newline at end of file
diff --git a/ECIPs/ECIP-1027.md b/ECIPs/ECIP-1027.md
new file mode 100644
index 00000000..18170042
--- /dev/null
+++ b/ECIPs/ECIP-1027.md
@@ -0,0 +1,220 @@
+### Title
+
+    ECIP: 1027
+    Title: Scaling ETC with Sidechains
+    Author: Igor Artamonov <splix@etcdevteam.com>
+    Status: Draft
+    Type: Standard
+    Created: 2017-07-17
+    
+
+# Abstract
+
+It’s proposed here to support Sidechains to Ethereum Classic blockchain as a first class citizens, effectively 
+sharding transactions between separate chains based on cheaper consensus algorithms (PoS, PoA, etc) and 
+using Main Ethereum Classic chain to transfer state between these chains and use as a security checkpoint 
+(Checkpoint Contract Consensus).
+
+Checkpoint Contract is based on Smart Contract way to track Sidechain state, it has special methods to store 
+Height/Difficulty/State of Sidechain in a separate parent chain. Consensus algorithm for a Side Chain could consider 
+this information stored in parent chain when synchronizing side chain.
+
+_**NOTE** This document propose a general idea, where some parts can be implemented in different ways, and will be 
+proposed with separate ECIPs_
+
+# Definitions
+
+ - Parent Chain - a blockchain to make checkpoints to
+ - Sidechain - a dependent blockchain that uses Parent Chain Checkpoints as part of Consensus
+ - Checkpoint - a status of Sidechain committed to Parent Chain
+ - Private Chain - a custom blockchain w/o public nodes
+ - Mainnet - main Ethereum Classic blockchain
+ - PoS - Proof Of Stake
+ - PoA - Proof Of Authority
+ 
+# Motivation
+
+One of the ways to provide Scalability is to split execution into several (semi-) independent parts and allow Peer 
+to process only that parts of whole chains that Peer is using. This approach is usually called Sharding.
+
+Proof Of Work consensus algorithm is proven to be good for chain security, but other consensus algorithms, such as 
+Proof Of Stake or Proof of Authority are better for performance and much cheaper in execution, and therefore are 
+good solution for Scalability.
+
+By combining them into a Hybrid Multichain, where chains is split into Sidechains with better performing consensus 
+algorithm, we can reach greater scalability. A business can have a fast and cheap chain for internal processing, 
+but having a security from public Proof Of Work ledger.
+ 
+Idea of Sidechain for scalability is not new, and different versions of same idea were discussed many times over 
+past years ([1], [2]). Most of these discussions were about applying Sidechains to Bitcoin, 
+which has a are limited execution model and it requires enhancements to start using it. Ethereum turing-complete 
+VM is much more flexible and allows to use this approach for scalability even without running a Hard Fork.
+
+# Specification
+
+## Overview
+
+A Peer configures Geth to follow a separate chain (Sidechain) and specifying a more secure chain (Parent Chain) 
+to make checkpoints through a special smart contract. For simplicity it could be two separate instances of Geth, 
+communicating through RPC API. For better usability it would be optimal to add ability to follow several chains from 
+same Geth instance.
+
+## Key points:
+
+ - There should be a special Smart Contract deployed to Parent Chain to manage checkpoints
+ - Checkpoints are transactions in Parent Chain
+ - Sidechain can read from Parent Chain and verify that it follows longest or most difficult Sidechain
+ - Mainnet is going to work as usual. Not a fork.
+
+It maybe helpful to introduce additional Opcodes to improve cross-transaction functionality. That will require a 
+protocol upgrade, but that’s optional and will be discussed in separate ECIPs
+
+## Types of chains
+
+There can be selected major 3 types of Sidechains:
+
+ - _Private chain_ - uses mainnet only for consensus
+ - _Trusted public chain_ - operated by a trusted party
+ - _Public chain_ - general use blockchain operated in untrusted environment
+
+### Private Chain (C1)
+
+Private Chain is a fully private chain executed in isolated environment which is using Parent Chain only as a security 
+mechanism.
+ 
+This can be a solution for many cases of a private corporate blockchains. This types of chain doesn’t share state with 
+parent chain, and therefore doesn’t need cross transactions, or can perform them in individual way when needed.
+
+Conception of making checkpoints on public secure blockchain is a popular idea in private chains and standalone 
+services, also called as Anchoring.
+
+See [ECIP-1028](ECIP-1028.md)
+
+### Trusted Public Chain (C2)
+
+Trusted Public Chain is a chain managed by a public service or Dapp, and such service provides full management of 
+that chain and performs cross operations for their users. Sidechain can use PoA or PoS for internal consensus, and a 
+separate Oracle/Validator like service to send/confirm user actions performed across the chains. For most of the cases 
+this chain could have a simple shared state, such as buying/selling internal tokens through a parent coin.
+ 
+Smart contracts for controlling shared state, and Transaction Replay like logic can give users additional security for 
+their cross-chain operations.
+
+_Example_: a smart contract based Token Exchange with Deposit/Withdraw through a special Smart Contract in Parent chain
+
+### Public Chain (C3)
+
+Public Chain is a general use blockchain, operated by multiple parties and in an untrusted environment. It can use a 
+fast PoS consensus algorithm for fast and cheap transactions, or individual configuration of EVM.
+
+## Checkpoint authorization
+
+Making a checkpoint will require verification mechanism to avoid corrupted state and to protect from malicious actors.
+
+For simple cases, when Sidechain is solely managed by one business (C1/C2 types), it’s enough to authorize an address 
+(or set of addresses) which can make such checkpoints.
+
+For more sophisticated chains (C2/C3 types) verification a Sidechain can use methods similar to Proof Of Stake, or 
+even implement full verification in a smart contract. Later is possible if a checkpoint can provide security by 
+validating only a chain headers and part of shared state.
+
+## Cross Transactions
+
+Cross-transactions for public Sidechain (C3) is most complicated part. In additional to untrusted environment it 
+can have multiple shared states managed by different types of services. It seems to be infeasible to implement a 
+general algorithm which will work for all cases. 
+
+There could be few possible solutions to that problem:
+ 
+ - Tx Replay through a Smart Contract, when Transaction Owner is separated from Transaction Executor. One example is 
+   Replay Attack Issue for ETH/ETC, when once signed transaction can be reused by a third party on a separate chain. 
+   This can also be implemented through a smart contract, where an input operation in one chain can be easily replayed 
+   by another network participant (which could also get a small fee for this) effectively making cross transactions 
+   between chains. By using Smart Contract implementation it’s possible to achieve required effect different by chain.
+ - Ideas from Polkadot [4] and Tendermint/Cosmos [5] can be applied here. Both this approaches are targeting more broad set 
+   of blockchains, so can be significantly simplified for this particular task.
+   
+To improve capabilities of EVM to handle support for cross transactions, it seems to be helpful to add new Opcodes to 
+do following:
+
+ - Get a hash of a whole `mapping` state of an address - that will allow to validate shared state on a checkpoint
+ - Signature validation for arbitrary data passed to a contract - that will allow to make same calls from another 
+   user (“replay tx”)
+   
+As there are few possible ways to implement such cross-chain transaction mechanism, it will be introduced in a series 
+of a separate ECIPs.
+ 
+# Key Features
+
+Proposed structure allows to use different EVM configuration per chain. It can be used for testing purposes, when a 
+part of the network is used a test playground for new features of EVM. A business can apply custom optimization and 
+additional features (OPCODES and Predefined Contracts) for their needs on their Sidechain. It could move most of 
+politics aside, as sides can choose own subset of Sidechains for their needs.
+
+Besides EVM it allows to use different type of VM for particular Sidechain, such as eWASM, WASM, JVM, etc
+
+More to that, it’s possible to implement Sidechain with a totally new execution structure, which can be optimized just 
+for one particular task, such as Token Transfer. Token Transfer Sidechain doesn’t need most of EVM features, therefore 
+it can be implemented in ways similar to Bitcoin UTXO, Lighting/Raiden network, or can be used together with 
+Zk-SNARKs, etc.
+
+A particular Sidechain is free to use own subset of Sidechain, and practically allows to use Three of Chains, based 
+on task or conditions. That could be a long living chain or ephemeral chain, global chain or geo-bounded chain 
+suitable for local network of IoT devices.
+
+# Alternatives to proposed approach
+
+ - _Address Space Sharding_ [6] - where a peer keeps only part of address space required for processing. This solution can 
+   be used together with proposed scheme and it gives additional joint for scalability.
+ - _Raiden Network_ [7] - basically it’s a Sidechain in terms of this proposal, and can be considered as one of the possible 
+   implementations of a Sidechain
+   
+# Implementation
+
+## Checkpoint Contract Interface
+
+Minimal interface usable for a private managed chain
+
+```
+makeCheckpoint(uint64 height, uint256 difficulty, uint256 blockHash, uint256 parentHash, uint256 stateHash)
+
+getLastCheckpoint() 
+   returns (uint64 height, uint256 difficulty, uint256 blockHash, uint256 parentHash, uint256 stateHash)
+```
+
+It’s possible that for some cases it will be required to keep other data within the checkpoint, at this case it’s 
+possible to extend parameters list with this new details. But for better compatibility and for standardization, it’s 
+suggested to introduce custom methods to manage other details associated with the checkpoint
+
+## Extended interface
+
+```
+getHeight() 
+    returns (uint64 height)
+  
+getBlocksCount(uint64 height) 
+    returns (uint8 count)
+    
+getCheckpoint(uint64 height, uint8 index) 
+    returns (uint256 difficulty, uint256 blockHash, uint256 parentHash, uint256 stateHash)
+```
+
+## Geth Enhancements
+
+Geth should have support for multiple consensus mechanisms, and a configuration for multiple chains. Part of this 
+is already implemented, and we can have multiple custom/private chains with Geth starting at version 3.4.0. Similar
+features are already implemented in Parity.
+
+It will also require improvements in user interface, new commands, configuration options and documentation. None of 
+this is a breaking change
+
+# References
+
+ 1. Enabling Blockchain Innovations with Pegged Sidechains (Adam Back, Matt Corallo, Luke Dashjr, Mark Friedenbach, Gregory Maxwell, Andrew Miller, Andrew Poelstra, Jorge Timón, and Pieter Wuille) - https://blockstream.com/sidechains.pdf
+ 2. Scaling Bitcoin with Sidechains - https://bitcointalk.org/index.php?topic=1083345.0 
+ 3. Sidechains, Drivechains, and RSK 2-Way peg Design - http://www.rsk.co/blog/sidechains-drivechains-and-rsk-2-way-peg-design
+ 4. Polkadot, a heterogeneous extensible multi-chain - http://polkadot.io/ 
+ 5. Cosmos: A Network of Distributed Ledgers (Jae Kwon, Ethan Buchman) - https://github.com/cosmos/cosmos/blob/master/WHITEPAPER.md#sidechains
+ 6. Ethereum ETH Sharding FAQ - https://github.com/ethereum/wiki/wiki/Sharding-FAQ
+ 7. Raiden Network - http://raiden.network/
+    
\ No newline at end of file
diff --git a/ECIPs/ECIP-1028.md b/ECIPs/ECIP-1028.md
new file mode 100644
index 00000000..e4414a3e
--- /dev/null
+++ b/ECIPs/ECIP-1028.md
@@ -0,0 +1,124 @@
+### Title
+
+    ECIP: 1028
+    Title: Private Sidechain checkpoints
+    Author: Igor Artamonov <splix@etcdevteam.com>
+    Status: Draft
+    Type: Standard
+    Created: 2017-07-18
+    
+    
+# Abstract
+
+This proposal is a part of Multi Chain proposal defined by ECIP-1027. It provides a solution for a Private Chain 
+based on Proof of Authority [1] connected to ETC Main Chain.
+
+# Motivation
+
+Private Chains with PoS or PoA consensus algorithms are common solution for global business that needs a 
+distributed way of processing data on blockchain. This types of blockchain are executed in trusted environment in 
+a private network, and don’t need any communication with external entities. PoS/PoA are able to provide most of 
+functionality required for such processing, but lack of security and data immutability usually provided by PoW.
+
+Checkpoints proposed in [ECIP-1027](ECIP-1027.md) are able to improve security and data immutability 
+of such Private Chains. 
+
+# Specification
+
+ - Network has a custom Private Chain working under Proof-of-Authority
+ - Network has a Checkpoint Contract in public ETC mainnet with methods `makeCheckpoint` and `getLastCheckpoint`
+ - Network has set of trusted nodes with access to external network to make checkpoint, this can be same nodes as 
+   PoA or different set of nodes. Checkpoint is made every N blocks, where N can reflect from 1 minute to few hours 
+   of blockchain time and it does not affect Private Chain performance under normal conditions.
+ - Checkpoint Contract has list of addresses with granted access to make checkpoints
+ - Only one possible checkpoint is possible per Block Height, and height of a new checkpoint must be higher that 
+   existing checkpoint. Otherwise Trusted Nodes should come to agreement about Correct Fork if a 
+   network split is observed, this logic can be implemented in the Checkpoint Contract as well.
+ - A checkpoint is a Hash of State Root + Block Height in the Private Chain, which does not leak any internal data 
+   to public chain (`Hash(StateRoot | BlockHeight)`)
+ - A Private Chain peer periodical check Checkpoint Contract and in case of chain split chooses chain cornered to 
+   that contract most recently.
+   
+# Implementation
+
+_WARNING_: following code is is for illustrative purpose only. It’s a very simplified implementation, should not 
+be used in a production system.
+
+## Contract
+
+````
+contract Checkpoint {
+
+   address historian;
+
+   uint64 height;
+   uint256 stateHash;
+
+   function Checkpoint() {
+       historian = msg.sender;
+   }
+
+   function makeCheckpoint(uint64 _height, uint256 _a, uint256 _b, uint256 _c, uint256 _stateHash) {
+       if (historian != msg.sender) {
+           throw;
+       }
+       if (_height <= height) {
+           throw;
+       }
+       height = _height;
+       stateHash = _stateHash;
+   }
+
+   function getLastCheckpoint() returns (uint64, uint256, uint256, uint256, uint256) {
+       return (height, 0, 0, 0, stateHash);
+   }
+
+}
+````
+
+## Consensus:
+````
+
+func MakeCheckpoint(contract *CheckpointContract, chain *BlockChain) {
+      height := chain.height()
+      block := chain.get(height)
+      hash := sha3(block.stateRoot, checkpointHeight)
+      contract.makeCheckpoint(height, nil, nil, nil, hash)
+}
+
+func (self *Checkpoint) FollowsCheckpoint(chain *BlockChain) bool {
+      checkpointHeight := self.height() //height at latest Checkpoint
+      checkpointHash := self.hash() //hash at latest Checkpoint
+      if (chain.height() < checkpointHeight) {
+             //chain is not fully synced yet, so maybe
+             return true
+      }
+      blockAtCheckpoint := chain.get(checkpointHeight)
+      chainHash := sha3(blockAtCheckpoint.stateRoot, checkpointHeight)
+      return chainHash == checkpointHash
+}
+
+func (self *Checkpoint) SelectFork(left *BlockChain, right *BlockChain) *BlockChain {
+      followLeft := self.FollowsCheckpoint(left)
+      followRight := self.FollowsCheckpoint(right)
+      if (followLeft && followRight) {
+             // Recent Split
+             return left.height() > right.height() ? left : right
+      }
+      if (followRight) {
+             return followRight
+      }
+      if (followLeft) {
+             return followRight
+      }
+      return nil
+}
+
+````
+
+# References
+
+ 1. Proof of Authority Chains - https://github.com/paritytech/parity/wiki/Proof-of-Authority-Chains
+ 2. Factom - Business Processes Secured by Immutable Audit Trails on the Blockchain (Paul Snow, Brian Deery, 
+   Jack Lu, David Johnston, Peter Kirby)
+    
\ No newline at end of file
diff --git a/ECIPs/ECIP-1029.md b/ECIPs/ECIP-1029.md
new file mode 100644
index 00000000..72ec7177
--- /dev/null
+++ b/ECIPs/ECIP-1029.md
@@ -0,0 +1,32 @@
+### Title
+
+    ECIP: 1029
+    Title: Include Uncles in Total Difficulty Calculation
+    Author: Wei Tang <hi@that.world>
+    Status: Draft
+    Type: Standard
+    Layer: Consensus (soft-fork)
+    Created: 2017-08-15
+    
+### Abstract
+
+This proposes to include uncle difficulty in total difficulty calcuation after `FORK_BLOCK`. New client will use a different [Ethereum Wire Protocol](https://github.com/ethereum/wiki/wiki/Ethereum-Wire-Protocol) version number to broadcast the total difficulty calculated using the new formula. As a result, old clients will continue to function if soft-forked clients are the majority.
+    
+### Background
+
+Ethereum is advertised to use [GHOST protocol](https://eprint.iacr.org/2013/881.pdf) for best chain selection. The calculation is done using "total difficulty". The client will always select the chain with larger total difficulty. However, while uncles are included in blocks and miners are rewarded to include them, they do not participate in the calculation of total difficulty thus do not participate in the best chain selection. This deflicts the goal of GHOST protocol, which should always select the chain in which, including stale blocks, is the heaviest.
+
+Analysis by [Gervais et al.](https://eprint.iacr.org/2016/555.pdf) has shown that, due to the above fact, Ethereum currently resembles a similar Proof of Work algorithm as Bitcoin. Besides, due to its fast block time (around 10 seconds) and growing block size, it is having a much larger orphan rate compared with other Proof of Work cryptocurrencies like Bitcoin, Litcoin and Dogecoin.
+
+### Specification
+
+Soft-forked clients support a new [Ethereum Wire Protocol](https://github.com/ethereum/wiki/wiki/Ethereum-Wire-Protocol) version number `70`. Before `FORK_BLOCK`, version `70` works the same as the current version `63`. On or after `FORK_BLOCK`, change the total difficulty calculation from `B_t = B'_t + B_d` to `B_t = B'_t + sum(B_U_d) + B_d`. That is, to also sum up difficulty of uncles included in the current block and add it to the total difficulty.
+
+Clients are recommended to continue to support older version number `62` and `63`. `62` and `63` should continue to use the old total difficulty calculation formula (`B_t = B'_t + B_d`) on or after `FORK_BLOCK`.
+
+Soft-forked clients should use version `70`'s total difficulty (with or without uniform tie breaking) for best chain selection.
+
+### References
+
+* Sompolinsky, Yonatan, and Aviv Zohar. "Accelerating bitcoin’s transaction processing." Fast Money Grows on Trees, Not Chains (2013).
+* Gervais, Arthur, et al. "On the security and performance of proof of work blockchains." Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security. ACM, 2016.
diff --git a/ECIPs/ECIP-1031.md b/ECIPs/ECIP-1031.md
new file mode 100644
index 00000000..47bb899c
--- /dev/null
+++ b/ECIPs/ECIP-1031.md
@@ -0,0 +1,29 @@
+### Title
+
+    ECIP: 1031
+    Title: Recursive Length Prefix Media Type
+    Author: Wei Tang <hi@that.world>
+    Status: Draft
+    Type: Standard
+    Layer: Meta
+    Created: 2017-08-29
+    
+### Abstract
+
+Recursive Length Prefix (see [Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) Appendix B) is the data type used for all common Ethereum Classic structures including blocks, raw transactions, receipts and accounts. Defining a media type for Recursive Length Prefix (RLP) would allow a RESTful HTTP server to return raw RLP information directly. This is more efficient than the current JSON format for RPC calls.
+
+### Specification
+
+Define a new media type according to RFC6838 under `application/vnd.ecip.rlp` ([IANA media type assignment](https://www.iana.org/assignments/media-types/application/vnd.ecip.rlp)). This media type has no required or optional parameters. It uses binary encoding. The specification for RLP can be found at [Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) Appendix B.
+
+### Example
+
+*Note this section is only served as an example of how this media type might be used, and is not part of the specification.*
+
+A client can implement a RESTful API that returns RLP binary data directly. We use the routes below, that partially implements the functionality of the current JSON RPC protocol.
+
+* `GET /{0xhex or number or latest or pending}`: returns RLP binary data of a given block.
+* `GET /{0xhex or number or latest or pending}/transactions/{0xhex or number}`: returns RLP binary data of a transaction.
+* `GET /{0xhex or number or latest or pending}/receipts/{0xhex or number}`: returns RLP binary data of a transaction receipt.
+* `PUT /pending/transactions`: accepts a raw RLP transaction input, and put it into the transaction mempool.
+* `GET /{0xhex or number or latest or pending}/accounts/{0xhex}`: returns the RLP binary data of an account.
diff --git a/ECIPs/ECIP-1032.md b/ECIPs/ECIP-1032.md
new file mode 100644
index 00000000..99f14a52
--- /dev/null
+++ b/ECIPs/ECIP-1032.md
@@ -0,0 +1,71 @@
+### Title
+
+    ECIP: 1032
+    Title: Readable Address and Transaction Hash
+    Author: Wei Tang <hi@that.world>
+    Status: Draft
+    Type: Standard
+    Layer: Meta
+    Created: 2017-09-02
+    
+### Abstract
+
+This defines convertion of address and transaction hash in Ethereum Classic network to readable strings, similar to how [Urbit](http://urbit.org/) handles its ship names. As an example, EthMine's coinbase address (0xdf7d7e053933b5cc24372f878c90e62dadad5d42) written in this scheme becomes `~hocwyt~misper~difmev~dabryd~livtep~dotpun~nibbex~nalbyn~pocmug~morden`.
+
+This ECIP only proposes an optional implementation for wallets and other dapp interface, and does not change anything in the underlying protocol, or in JSON RPC.
+
+### Motivation
+
+Ethereum Classic's address is 160-bit, and transaction hash is 256-bit. They're currently only represented in a long hex string. This, when exchanged by users (for example, in situations where it needs to be transmitted by hand) can result in errors. This ECIP proposes a way to rewrite the 160-bit address or the 256-bit transaction hash in a human readable way similar to Urbit.
+
+### Specification
+
+Group the bytearray of 160-bit addresses or 256-bit transaction hashes into pairs of two bytes. For each pair, use `names` at index of the first item of the pair, appended by `endings` at index of the second item of the pair. Each pair is also prefixed by `~`. The list of `names` and `endings` can be found in the Python implementation in the appendix.
+
+#### Generate shorter address
+
+When an address starts with `2*x` bytes of zero, they can be ignored and not included in the readable string generation. The last "prefix" can also be ignored if it is zero.
+
+### Hex Readability Fix
+
+In addition, allow `.` to be put in a hex address string for every two bytes. For example, EthMine's coinbase address (0xdf7d7e053933b5cc24372f878c90e62dadad5d42) becomes `0xdf7d.7e05.3933.b5cc.2437.2f87.8c90.e62d.adad.5d42`. Dot is used because it is the same character used in Urbit and in IPv4 addresses.
+
+### Reference
+
+* [Request for comment: @p draft](https://groups.google.com/forum/#!msg/urbit-dev/yTsrEGe9gso/FgLczcg0ocQJ) in Urbit mailing list.
+* [Issue 488](https://github.com/urbit/urbit/issues/488) in Urbit repository.
+
+### Appendix: Reference Python Implementation
+
+Below is a reference Python implementation for this ECIP.
+
+```python
+names = "dozmarbinwansamlitsighidfidlissogdirwacsabwissibrigsoldopmodfoglidhopdardorlorhodfolrintogsilmirholpaslacrovlivdalsatlibtabhanticpidtorbolfosdotlosdilforpilramtirwintadbicdifrocwidbisdasmidloprilnardapmolsanlocnovsitnidtipsicropwitnatpanminritpodmottamtolsavposnapnopsomfinfonbanmorworsipronnorbotwicsocwatdolmagpicdavbidbaltimtasmalligsivtagpadsaldivdactansidfabtarmonranniswolmispallasdismaprabtobrollatlonnodnavfignomnibpagsopralbilhaddocridmocpacravripfaltodtiltinhapmicfanpattaclabmogsimsonpinlomrictapfirhasbosbatpochactidhavsaplindibhosdabbitbarracparloddosbortochilmactomdigfilfasmithobharmighinradmashalraglagfadtopmophabnilnosmilfopfamdatnoldinhatnacrisfotribhocnimlarfitwalrapsarnalmoslandondanladdovrivbacpollaptalpitnambonrostonfodponsovnocsorlavmatmipfip"
+endings = "zodnecbudwessevpersutletfulpensytdurwepserwylsunrypsyxdyrnuphebpeglupdepdysputlughecryttyvsydnexlunmeplutseppesdelsulpedtemledtulmetwenbynhexfebpyldulhetmevruttylwydtepbesdexsefwycburderneppurrysrebdennutsubpetrulsynregtydsupsemwynrecmegnetsecmulnymtevwebsummutnyxrextebfushepbenmuswyxsymselrucdecwexsyrwetdylmynmesdetbetbeltuxtugmyrpelsyptermebsetdutdegtexsurfeltudnuxruxrenwytnubmedlytdusnebrumtynseglyxpunresredfunrevrefmectedrusbexlebduxrynnumpyxrygryxfeptyrtustyclegnemfermertenlusnussyltecmexpubrymtucfyllepdebbermughuttunbylsudpemdevlurdefbusbeprunmelpexdytbyttyplevmylwedducfurfexnulluclennerlexrupnedlecrydlydfenwelnydhusrelrudneshesfetdesretdunlernyrsebhulrylludremlysfynwerrycsugnysnyllyndyndemluxfedsedbecmunlyrtesmudnytbyrsenwegfyrmurtelreptegpecnelnevfes"
+
+def split_len(seq, length):
+    return [seq[i:i+length] for i in range(0, len(seq), length)]
+
+prefix = split_len(names, 3)
+suffix = split_len(endings, 3)
+
+def hex_to_readable(data, skip):
+    ret = ""
+    for i in range(0, len(data) // 2):
+        if skip and data[i*2] == 0 and data[i*2+1] == 0:
+            continue
+        if skip and i*2 == len(data) // 2 - 2 and data[i*2] == 0:
+            continue
+        ret += "~%s%s" % (prefix[data[i*2]], suffix[data[i*2+1]])
+    if ret == "":
+        ret += "~%s%s" % (prefix[0], suffix[0])
+    return ret
+
+def address_to_readable(address):
+    return hex_to_readable(bytearray.fromhex(address), True)
+
+def transaction_to_readable(transaction):
+    return hex_to_readable(bytearray.fromhex(transaction), False)
+
+print(address_to_readable("df7d7e053933b5cc24372f878c90e62dadad5d42"))
+```
diff --git a/ECIPs/ECIP-1033.md b/ECIPs/ECIP-1033.md
new file mode 100644
index 00000000..2931a4c3
--- /dev/null
+++ b/ECIPs/ECIP-1033.md
@@ -0,0 +1,23 @@
+### Title
+
+    ECIP: 1033
+    Title: Mnemonic code for public address
+    Author: Wei Tang <hi@that.world>
+    Status: Draft
+    Type: Standard
+    Layer: Meta
+    Created: 2017-09-02
+    
+### Abstract
+
+This extends [BIP-39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) for public addresses on the Ethereum Classic network. As an example, address `0xdf7d7e053933b5cc24372f878c90e62dadad5d42` becomes `term-typical-life-include-deputy-toward-move-tourist-maple-goose-define-forget-suspect-push-any`.
+
+### Specification
+
+The address is taken as a bytearray. A checksum is generated by taking the first 5 bits of the SHA256 hash of the address. This checksum is appended to the end of the bytearray. Next, these concatenated bits are split into groups of 11 bits, each encoding a number from 0-2047, serving as an index into a wordlist. Finally, we convert these numbers into words and use the joined words as a mnemonic sentence.
+
+Words are connected by `-` in English and other Latin languages. There's currently no defined scheme for non-Latin languages like Chinese.
+
+### Wordlist
+
+We use the same word list as in BIP-39.
diff --git a/ECIPs/ECIP-1034.md b/ECIPs/ECIP-1034.md
new file mode 100644
index 00000000..a78e58e2
--- /dev/null
+++ b/ECIPs/ECIP-1034.md
@@ -0,0 +1,57 @@
+### Title
+
+    ECIP: 1034
+    Title: Message Signing and Verification in JSON RPC
+    Author: Wei Tang <hi@that.world>
+    Status: Draft
+    Type: Standard
+    Layer: JSON RPC
+    Created: 2017-09-05
+   
+### Motivation
+
+The current `eth_sign` definition is different across different client implementation, which creates [many](https://github.com/ethereumproject/go-ethereum/issues/323) [problems](https://github.com/paritytech/parity/issues/5490). In addition, there is currently no way to verify a signed message using JSON RPC. This ECIP defines two new RPC calls `sign` and `recover` in a different namespace.
+
+### Namespace
+
+The author of this ECIP recommends to define the two new RPC in a different namespace rather than `eth`. Reusing `eth` may cause confusion with the existing `eth_sign` RPC call and might further pollute the already huge namespace. We can use `etc` namespace, or `key` namespace.
+
+### Specification
+
+#### `[namespace]_sign`
+
+This sign method calculates an Ethereum specific signature of the following Recursive Length Prefix (RLP) structure (call it Message RLP):
+
+* A 16-byte bytearray of magic code: `0x457468657265756d207369676e6d7367` (ASCII string of "Ethereum signmsg").
+* The binary bytearray of the message (`message` in parameters).
+
+Similar to [eth_sign](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign), by adding a prefix, it prevents misuse where a malicious DApp can sign arbitrary data (e.g. transaction) and use the signature to impersonate the victim.
+
+##### Parameters
+
+1. `account`: 20 bytes address.
+2. `message`: N bytes message.
+3. `detached`: (Optional) If true, detach the message from the signing result. By default, this is false.
+
+##### Returns
+
+The signing process takes the Keccak256 hash of the above Message RLP structure as the actual message to be signed by secp256k1. It uses the specified account private key to sign a private message. The returned data is also a RLP structure (encoded as hex string):
+
+* A 65-byte bytearray of the signature. The first byte is the recovery id, followed by 64 bytes of the signature data.
+* The Keccak256 message hash used in the secp256k1 signing process.
+* (Only included if `detached` is false) Message RLP defined above.
+
+#### `[namespace]_recover`
+
+Recover a signature signed by `[namespace]_sign`.
+
+##### Parameters
+
+`signature`: returned data by `[namespace]_sign`.
+
+##### Returns
+
+If the signature is invalid, return `false`. Otherwise, returns the following JSON struct.
+
+1. `address`: Address used to sign this message.
+2. `message`: If the signature is not detached, returns the actual message (excluding the prefix "Ethereum signmsg") of the signature.
diff --git a/ECIPs/ECIP-1035.md b/ECIPs/ECIP-1035.md
new file mode 100644
index 00000000..5eea8923
--- /dev/null
+++ b/ECIPs/ECIP-1035.md
@@ -0,0 +1,146 @@
+    ECIP: 1035
+    Title: Ethereum Classic Privacy Enhanced Stealth Address Schema
+    Author: Cody Burns <DontPanic@codywburns.com>
+    Status: Draft
+    Type: Process
+    Created: 2017-09-05
+  
+### Abstract 
+
+Currently user accounts are represented in a manner that allows for any third party who know a user’s public account number to review all transactions and interactions associated with that account creating a linkable transaction history. While these addresses are good for transactions requiring psudeo-identity( contracts, tokens, etc), it is not ideal for standard user accounts.  The purpose of a stealth addressing scheme is to create one-time addresses which are publicly unlinkable to the owner or any other one-time addresses and allow for only the recipient to link transactions and derive the secret key associated with the address. In short, with a privacy enhanced ethereum classic (ETC-PE) capable node a user can publish one address and receive publicly unlinkable payments as well as make traditional ethereum transactions. This type of cryptographic scheme is described in detail in the cryptonote whitepaper.
+
+### Definitions
+
+`Private Key`(yellowpaper: pr) is a standard elliptic curve private key: a ∈ [1, secp256k1n − 1].
+
+`Public Key` (yellowpaper: pu) is a standard elliptic curve public key: a point pu = prG; 
+
+`one-time keypair` is a pair of private and public keys; 
+
+`private user key` is a pair (a, b) of two different private ec-keys; 
+
+`public user key` is a pair (A, B) of two public ec-keys derived from (a, b); 
+
+`Public Spend Key` is a standard elliptic curve public key: A = aG used to spend transactions
+
+`Public View Key` is a standard elliptic curve public key: B = bG used to view transactions
+
+`Random private key` random nonce where r ∈ [1, secp256k1n − 1];
+
+`Random public key` is a standard elliptic curve public key: a point R = rG;
+
+`tracking key` is a pair (a, B) of private and public ec-key (where B = bG and a 6= b); 
+
+`standard address` is a representation of a public user key given into human friendly string with error correction; 
+
+`truncated address` is a representation of the second half (point B) of a public user key given into human friendly string with error correction. 
+
+`Standard Ethereum address`(yellow paper: A(pr)) rightmost 160-bits of the Keccak hash of the corresponding ECDSA public key  A(pr) = B96..255(KEC(ECDSAPUBKEY(pr))) 
+
+`Contract Address` rightmost 160 bits of the Keccak hash of the RLP encoding of the structure containing only the sender and the nonce. a ≡ B96..255(KEC(RLP((s, σ[s]n − 1)))
+
+`Transaction Extra Data`An unlimited size byte array specifying the input data of the message call, formally Td 
+
+
+
+### Stealth Address
+
+![image alt text](ECIP-1035-Stealth.png)
+
+Cryptonote whitepaper Figure 4
+
+#### The Alice and Bob
+
+ Alice wants to send a payment to Bob. 
+
+Alice= Private spend key (Prz)and Private View Key (Pry)
+
+Alice= Public Address (Z,Y)
+
+Bob = Public Address (A,B)
+
+Bob = Private spend key (Pra)and Private View Key (Prb)
+
+Alice and Bob know each others Public Address
+
+#### Send Process
+	
+  Alice chooses a random private key r  and calculates R = rG. r is no longer needed after this point, however it may be retained to prove Alice sent the transaction to a 3rd party. A new r should be used with every transaction.  R is added to the transactions extradata prefixed with: halt code `0x00`  and a version byte `01` to prevent accidental evm functioning and to allow for rapid lookup. 
+	
+  `Td=0x0001(R)`
+
+Alice then generates a stealth address `P` 
+
+`P = KEC(rA)G+B`
+
+Where:
+
+`P` is the final stealth address;
+
+`KEC` is the hashing algorithm;
+
+`r` is Alice’s random private key;
+
+`A` is Bobs Public View key
+
+`G` is the standard base point;
+
+`B` is  Bobs Public spend key
+
+#### Receiving Process
+
+Bob's ETC-PE node checks every transaction with his private key (a,b) and computes 
+
+`P’ = KEC(aR)G+B`
+
+Where:
+
+`P’` is an address;
+
+`KEC` is the hashing algorithm;
+
+`a` is Bobs Private View Key
+
+`R` is a transactions extra Data begingin with `0x0001`
+
+`G` is the standard base point;
+
+`B` is  Bobs Public spend key
+
+If Alice’s transaction for with Bob as the recipient was among them:
+
+`aR = arG = rA` and `P’ = P`
+
+Bob can recover the corresponding one-time private key: 
+
+`x = KEC(aR) + b, so as P = xG`
+
+Bob can spend this output at any time by signing a transaction with `x`.
+
+### Rationale
+
+Having both legacy, contract, and stealth account schema allows for additional privacy features to be incorporated into the ethereum classic ecosystem. The stealth account schema by themselves provide the benefit of a unique account per transaction, it is computationally non-trivial for a third party to determine Bobs true holdings.
+
+Additional notes from Cryptonote white paper:
+
+• When Bob “recognizes” his transactions (see step 5) he practically uses only half of his private information: (a, B). This pair, also known as the tracking key, can be passed to a third party (Carol). Bob can delegate her the processing of new transactions. Bob doesn’t need to explicitly trust Carol, because she can’t recover the one-time secret key p without Bob’s full private key (a, b). This approach is useful when Bob lacks bandwidth or computation power (smartphones, hardware wallets etc.). 
+
+• In case Alice wants to prove she sent a transaction to Bob’s address she can either disclose r or use any kind of zero-knowledge protocol to prove she knows r (for example by signing the transaction with r). 
+
+• If Bob wants to have an audit compatible address where all incoming transaction are linkable, he can either publish his tracking key or use a truncated address. That address represent only one public ec-key B, and the remaining part required by the protocol is derived from it as follows: a = Hs(B) and A = Hs(B)G. In both cases every person is able to “recognize” all of Bob’s incoming transaction, but, of course, none can spend the funds enclosed within them without the secret key b. 
+
+
+### Backwards Compatibility
+
+This ECIP is applicable at the node/client level and has no effect on consensus. It is fully backwards compatible. Any node not upgrade to ETC-PE addressing will view the transactions as normal transactions with extra data. ETC-PE nodes should retain legacy addressing as well for interacting with contracts.  
+
+
+### Copyright
+
+Copyright and related rights waived via CC0.
+
+
+### Ref
+
+ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER EIP-150 REVISION, Dr. Gavin Wood, http://yellowpaper.io/
+CryptoNote v 2.0, Nicolas van Saberhagen ,https://cryptonote.org/whitepaper.pdf
diff --git a/ECIPs/ECIP-1036.md b/ECIPs/ECIP-1036.md
new file mode 100644
index 00000000..b9f23bdf
--- /dev/null
+++ b/ECIPs/ECIP-1036.md
@@ -0,0 +1,30 @@
+### Title
+
+    ECIP: 1036
+    Title: Fallback Complete Difficulty Bomb Diffusion
+    Author: Wei Tang <hi@that.world>
+    Status: Draft
+    Type: Standard
+    Layer: Consensus
+    Created: 2017-09-06
+    
+### Abstract
+
+This ECIP describes a fallback plan if an extension of ECIP-1010 does not activate. If that is the case, then completely diffuse the difficulty bomb at block 5452163.
+    
+### Motivation
+
+There is currently a small probability that [an extension of ECIP-1010](https://github.com/ethereumproject/ECIPs/issues/63) might not be able to be activated. The probability is really slight, but it is still possible. Please see the discussion of that issue for reasonings from different parties. This ECIP provides a fallback plan, to give assurance for those who might be impantient or worried of the difficulty bomb, so as to avoid a possible community split or an unexcepted hard fork.
+
+Block 5452163 is chosen as the fork block number. This is a totally arbitrary and meaningless number. In this way, we avoid collisions of the fork block number with other protocol upgrade hard forks.
+
+### Specification
+
+If [an extension of ECIP-1010](https://github.com/ethereumproject/ECIPs/issues/63) is rejected, at block 5452163, change the difficulty calculation formula to:
+
+```
+block_diff = parent_diff 
+     + parent_diff / 2048 * max(1 - (block_timestamp - parent_timestamp) / 10, -99) 
+```
+
+That is, remove the `int(2**explosion)` part from the formula in ECIP-1010.
diff --git a/ECIPs/ECIP-1037.md b/ECIPs/ECIP-1037.md
new file mode 100644
index 00000000..83a81dc8
--- /dev/null
+++ b/ECIPs/ECIP-1037.md
@@ -0,0 +1,265 @@
+<pre>
+  ECIP: 1037
+  Layer: Applications
+  Title: Simple Interactive URI Scheme
+  Author: Cody Burns <dontpanic@codywburns.com>
+  Comments-Summary: No comments yet
+  Status: Draft
+  Type: Standards Track
+  Created: 20170909
+</pre>
+
+This ECIP is based off BIP 0021 can be referenced at https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki
+
+==Abstract==
+This ECIP proposes a URI scheme for interacting with ethereum contract and accounts in a uniform standard format. 
+
+==Motivation==
+The purpose of this URI scheme is to enable users to easily make payments and interact with smart contracts by simply clicking links on webpages or scanning QR Codes. This allows for nfc, qr codes, or other similar non-interactive devices to store and transmit a standard message to a user, as well as interactive applications such as websites and dApps to present simple data to a user for action 
+
+==Specification==
+
+=== General rules for handling (important!) ===
+
+ETC clients MUST NOT act on URIs without getting the user's authorization.
+They SHOULD require the user to manually approve each payment individually, though in some cases they MAY allow the user to automatically make this decision.
+ETC clients SHOULD include the message field describing the actions of the code.
+
+=== Operating system integration ===
+Graphical ethereum clients SHOULD register themselves as the handler for the "ethereum:" URI scheme by default, if no other handler is already registered. If there is already a registered handler, they MAY prompt the user to change it once when they first run the client.
+
+=== General Format ===
+
+Ethereum URIs follow the general format for URIs as set forth in RFC 3986. The path component consists of an Ethereum address, and the query component provides additional payment options.
+
+Elements of the query component may contain characters outside the valid range. These must first be encoded according to UTF-8, and then each octet of the corresponding UTF-8 sequence must be percent-encoded as described in RFC 3986.
+
+=== ABNF grammar ===
+
+ ethereumurn     = "ethereum:" ethereumaddress & ethereumchainid [ "?" ethereumparams ]
+ ethereumaddress = *hexdig
+ ethereumchainid = "id=" *digit
+ ethereumparams  = ethereumparam [ "&" ethereumparams ]
+ ethereumparam   = [ amountparam / gasparam / gaslimitparm / nonceparam / codeparam / labelparam / messageparam / otherparam / reqparam]
+ amountparam     = "amount=" *digit [ "." *digit ]
+ gasparam        = "gas=" *digit
+ gaslimitparm    = "glmt=" *digit
+ nonceparam      = "n=" *digit
+ codeparam       = "code=" *hexdig
+ labelparam      = "label=" *qchar
+ messageparam    = "message=" *qchar
+ otherparam      = qchar *qchar [ "=" *qchar ]
+ reqparam        = "req-" qchar *qchar [ "=" *qchar ]
+
+Here, "qchar" corresponds to valid characters of an RFC 3986 URI query component, excluding the "=" and "&" characters, which this ECIP takes as separators.
+
+The scheme component ("ethereum:") is case-insensitive, and implementations must accept any combination of uppercase and lowercase letters. The rest of the URI is case-sensitive, including the query parameter keys.
+
+=== Query Keys ===
+
+*address: ethereum account or contract address in hexidecimal 
+*id: eip 155 compliant chainid, used for sanity check 
+*amount = amount of ether to transfer, denominated in ETC
+*gas = gas price
+*gaslmt = amount of gas transaction is not to exceed
+*nonce = account nonce 
+*code = byte code data for transaction
+*label: Label for that address (e.g. name of receiver)
+*message: message that describes the transaction to the user ([[#Examples|see examples below]])
+*(others): optional, for future extensions
+
+
+=== EIP 155 Transaction === 
+
+The intent of the uri is to pass all information nessecarry for forming a raw transaction to another device or service for signing. 
+
+A raw transaction should map the uri functions as follows for RLP encoding:
+
+ var rawTX = {
+        nonce = nonceparam,
+        gasprice =  gasparam,
+        gaslimit = gaslimitparam,
+        to =  ethereumaddress,
+        value = amountparam * 10**18,
+        data = codeparam,
+        v = ethereumchainid,
+        r = '',
+        s = ''
+        }
+
+The parameters labelparam, messageparam, otherparam, and reqparam are not used in transaction signing and can be optionally displayed to the user to pass additional information about the transaction. 
+
+        
+==== Transfer amount/size ====
+
+If an amount is provided, it MUST be specified in decimal ETC.
+All amounts MUST contain no commas and use a period (.) as the separating character to separate whole numbers and decimal fractions.
+I.e. amount=50.00 or amount=50 is treated as 50 ETC, and amount=50,000.00 is invalid.
+
+ETC clients MAY display the amount in any format that is not intended to deceive the user.
+They SHOULD choose a format that is foremost least confusing, and only after that most reasonable given the amount requested.
+For example, so long as the majority of users work in ETC units, values should always be displayed in ETC by default, even if wei would otherwise be a more logical interpretation of the amount.
+
+=== ENS addresses ===
+
+The Ethereum Name Service is a protocol and ABI definition that provides flexible resolution of short, human-readable names to service and resource identifiers. This permits users and developers to refer to human-readable and easy to remember names, and permits those names to be updated as necessary when the underlying resource (contract, content-addressed data, etc) changes.
+
+ENS names must conform to the following syntax:
+
+ <domain> ::= <label> | <domain> "." <label>
+ <label> ::= any valid string label per [UTS46](http://unicode.org/reports/tr46/)
+
+For the specification of the URI, <label> resolves into the following ethereumchainid:
+
+{|  class="wikitable" style="text-align: left;"
+|-
+! scope="col" width="width:20em;" | TLD
+! scope="col" width="width:20em;" | Chain_ID
+! scope="col" width="width:20em;" | Chain
+|-
+|.eth
+|1
+|Ethereum mainnet
+|-
+|.exp
+|2
+|Expanse mainnet
+|-
+|.rsk
+|30
+|Rootstock mainnet
+|-
+|.etc
+|61
+|Ethereum Classic mainnet
+|-
+|}
+
+=== Bytecode Transactions ===
+
+Events and functions in evm contracts are / can be preformatted to know functions in the underlying contract. The first four bytes of the call data for a function call specifies the function to be called. It is the first (left, high-order in big-endian) four bytes of the Keccak (SHA-3) hash of the signature of the function. This information along, with the appropriate hex encoded data to pass, form the bytecode.
+
+====Example====
+
+Contract C is at 0xdeadbeef... and has the following psudo function:
+
+
+ function getETC(){
+    require(block.number-payoutDrip >= payoutRate);
+    msg.sender.transfer(dropValue);   
+    }
+
+Contract C requires no inputs and only requires enough gas to preform its functions. The byte code for this function can be derived using `web3` as:
+ 
+  web3.sha3("getETC()");
+
+which yeilds:
+ 
+ 0x023b88685d10d29e0bf0563e4ab1b9d8fc8333c166705be5538c4b079cdd9af0
+
+The information that will be passed in the byte code field would then be:
+ 
+ code=0x023b8868
+
+The entire URi could be:
+          
+ ethereum:0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef&id=61?code=0x023b8868
+
+
+Bytecode specifications can be found in their respective documentation.
+
+== Rationale ==
+
+===Payment identifiers, not person identifiers===
+Current best practices are that a unique address should be used for every transaction.
+Therefore, a URI scheme should not represent an exchange of personal information, but a one-time payment or function call.
+
+===Accessibility (URI scheme name)===
+Should someone from the outside happen to see such a URI, the URI scheme name already gives a description.
+A quick search should then do the rest to help them find the resources needed to make their payment.
+Other proposed names sound much more cryptic; the chance that someone googles that out of curiosity are much slimmer.
+Also, very likely, what he will find are mostly technical specifications - not the best introduction to ETC.
+
+===Contract Code===
+
+It is not the intent of this ECIP to define every possible contract code that could be implimented.
+Higher level functionality would be provided by the site creating the URI qr code and, for lack of a better term,
+black box it to the application scanning the code. As generating qr-codes is trivial on an application compared to 
+the hazard of unlocking a private key, an application should be able to produce a URI that is functionally similar 
+to a standard transaction without the account specific details.
+
+Best practices in function codes shold be adhered to and this ECIP should remain forward compatable.
+It is recommended that dApps should make effort to include in the message what is being accomplished in the code.
+
+
+==Forward compatibility==
+Variables which are prefixed with a req- are considered required.  If a client does not implement any variables which are prefixed with req-, it MUST consider the entire URI invalid.  Any other variables which are not implemented, but which are not prefixed with a req-, can be safely ignored.
+
+==Backward compatibility==
+As this ECIP is written, several clients already implement a ethereum: URI scheme similar to this one, however usually without the additional "req-" prefix requirement.  Thus, it is recommended that additional variables prefixed with req- not be used in a mission-critical way until a grace period of 6 months from the finalization of this ECIP has passed in order to allow client developers to release new versions, and users of old clients to upgrade.
+
+== Appendix ==
+
+=== Simpler syntax ===
+
+This section is non-normative and does not cover all possible syntax.
+Please see the BNF grammar above for the normative syntax.
+
+[foo] means optional, &lt;bar&gt; are placeholders
+
+ <nowiki>ethereum:<address>&id=<chainid>[?amount=<amount>][&gas=<startGas>][&glmt=<gaslimit>][&n=<nonce>][&code=<data>][&label=<label>][&message=<message>]</nowiki>
+
+=== Examples ===
+
+Just the address:
+ ethereum:0xCe5ED529977b08f87CBc207ebC216859820461eE&id=61
+
+Address with name:
+ ethereum:0xCe5ED529977b08f87CBc207ebC216859820461eE&id=61?label=DontPanic
+
+Request 20.30 ETC to "DontPanic":
+ ethereum:0xCe5ED529977b08f87CBc207ebC216859820461eE&id=61?amount=20.3&label=DontPanic
+
+Request 42.30 ETC to "DontPanic" with gas:
+ ethereum:0xCe5ED529977b08f87CBc207ebC216859820461eE&id=61?amount=20.3&gas=21000&label=DontPanic
+
+Request 50 ETC with message:
+ ethereum:0xCe5ED529977b08f87CBc207ebC216859820461eE&id=61?amount=50&label=DontPanic&message=Purchase%20token%20for%20project%20xyz%20ICO
+
+Request a function call in a contract:
+ ethereum:0xCe5ED529977b08f87CBc207ebC216859820461eE&id=61?amount=50&code=0x2066726f6d204a656666204761727a696b20666f7220746f6b656e206d696e74
+
+Some future version that has variables which are (currently) not understood and required and thus invalid:
+ ethereum:0xCe5ED529977b08f87CBc207ebC216859820461eE&id=61?req-somethingyoudontunderstand=50&req-somethingelseyoudontget=999
+
+Some future version that has variables which are (currently) not understood but not required and thus valid:
+ ethereum:0xCe5ED529977b08f87CBc207ebC216859820461eE&id=61?somethingyoudontunderstand=50&somethingelseyoudontget=999
+
+Characters must be URI encoded properly.
+
+== Reference Implementations ==
+
+=== Libraries ===
+
+=== References ===
+
+BIP 21: Bitcoin URI Scheme
+https://github.com/bitcoin/bips/blob/master/bip-0021.mediawik
+
+ERC: Standard URI scheme with metadata, value and byte code
+https://github.com/ethereum/EIPs/issues/67
+
+RFC 3986
+https://www.ietf.org/rfc/rfc3986.txt
+
+EIP 155: Simple replay attack protection
+https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md
+
+EIP 137: Ethereum Domain Name Service - Specification
+https://github.com/ethereum/EIPs/blob/master/EIPS/eip-137.md
+
+Solidity in depth
+http://solidity.readthedocs.io/en/develop/abi-spec.html#examples
+
+Ethereum Yellow Paper
+http://yellowpaper.io/
diff --git a/ECIPs/ECIP-1038.md b/ECIPs/ECIP-1038.md
new file mode 100644
index 00000000..f9116cc2
--- /dev/null
+++ b/ECIPs/ECIP-1038.md
@@ -0,0 +1,67 @@
+### Title
+
+    ECIP: 1038
+    Title: Jets in Ethereum Virtual Machine
+    Author: Wei Tang <hi@that.world>
+    Status: Draft
+    Type: Standard
+    Layer: Application
+    Created: 2017-11-04
+    
+### Abstract
+
+Jets are optimization marks. Using jets, users can place optmization marks in an EVM program. An EVM interpreter will then verify the optimization mark claim, and if the verification passes, execute a native code version of the program that is equivalent to the original program.
+
+### Specification
+
+The optimization mark is defined as two adjencent opcodes.
+
+```
+PUSH11 45 56 4d 4a 45 54 53 <4 bytes of registry ID>
+POP
+```
+
+Readers can immediately follow that this optimization mark does not have side effects other than costing 5 gases. `45 56 4d 4a 45 54 53` is a magic code. The `<4 bytes of registry ID>` is interpreted as a big-endian unsigned integer.
+
+EVMs, on doing the initial `JUMPDEST` validity map execution round, can optionally search for the optimization mark as defined above. If an optimization mark is found, it then checks whether the `registry ID` is supported. Each `registry ID` has an associated code length. The EVM then verify that opcodes followed by the optimization mark, of code length, is a pre-defined one. If so, it can mark the beginning of that code region `A` (including the optimization mark) as "jet-able". When the program counter reads up to `A`, the EVM can choose to execute the jet-ed native code that results in the same state, and costs the same gas. However, if the program counter instead jumps to the middle of the code region, it should use the not-jet-ed unoptimized opcode.
+
+### Registry ID Assignments
+
+Registry ID of ECIP-1038 can be assigned in a looser process but similar to how ECIP works. EVM implementors can choose to implement any registry ID or not, but should avoid conflicting registry ID assignments. An assigment must also contain:
+
+* The code length of the optimizing block.
+* The opcode sequence of the optimizing block.
+* Sample implementation of the optimizing block.
+
+### Example
+
+Usually for an opcode sequence to be replacable by native codes, it is required that it to be static:
+
+* Jumps need to be deterministic. The sequence can use `PC` opcode to jump to an offset of the current position.
+* It cannot jump out of its region.
+
+Below we consider the opcode `MUL` does not exist, and implement a jet-able version of `MUL` using `ADD`:
+
+```
+PUSH1 00
+DUP2
+DUP4
+ADD
+ADD
+SWAP2
+PUSH1 01
+SWAP1
+SUB
+SWAP2
+DUP3
+PC
+PUSH1 11
+SUB
+SWAP1
+JUMPI
+SWAP2
+POP
+POP
+```
+
+This can be simplified by `MUL` -- taking two items from the stack, and push one new item which is the multiply of the two items. Its gas cost can also be simplified as `12 + 51 * <mul second item>`.
diff --git a/ECIPs/ECIP-1040.md b/ECIPs/ECIP-1040.md
new file mode 100644
index 00000000..11405664
--- /dev/null
+++ b/ECIPs/ECIP-1040.md
@@ -0,0 +1,68 @@
+### Title
+
+    ECIP: 1040
+    Title: Maintain Existing Account Compatibility While Hard Forking
+    Author: Wei Tang <hi@that.world>
+    Status: Draft
+    Type: Standard
+    Layer: Meta/Consensus
+    Created: 2017-12-30
+    
+### Abstract
+
+This defines a method of hard forking while maintaining the exact functionality of existing account by allowing multiple versions of the virtual machines to execute in the same block. This is also useful to define future account state structures when we introduce the on-chain WebAssembly virtual machine.
+
+### Motivation
+
+When EIP150 was activated on Ethereum Classic, it was critised that it changes the behaviour of many existing smart contracts on the blockchain, and made several ones unusable. The same thing will also happen in the future if we decided to add some of the Byzantium hard forks to Ethereum Classic.
+
+Take the REVERT opcode as an example. Currently there're already many contracts on the Ethereum Classic blockchain with the REVERT opcode. This opcode is now considered invalid. When EVM executes to REVERT, it will treat it as an invalid opcode, consume all the gases, and return an error. However, when we hard fork to define the actual REVERT, existing users would suddenly find that the behavior of their existing contract would have changed -- instead of consuming all gases, it will now only consume less than the given gas limit and return. Several on-chain contract might rely on the old behavior for some of their functionality. Besides, if a dapp developer does not follow the hard fork, he or she will suddenly find that the dapp might suddenly break because the existing method to detect whether a contract execution succeeds or not does not work any more.
+
+One of the important mission of blockchain is to "become your own bank". In Bitcoin, that means once a transaction is executed, the fund will always be controlled by the receiver unless he or she sends it out again. In Ethereum, an additional important property is that, once a smart contract is deployed, it should always execute in the original expected manner. As a result, it is important to have a way to **maintain compatibility of existing contracts** and at the same time **easily add new protocol features**.
+
+Note that this specification might not apply to all hard forks. We have emergency hard forks in the past due to network attacks. Whether they should maintain existing account compatibility should be evaluated in individual basis. If the attack can only be executed once against some particular contracts, then the scheme defined here might still be applicable. Otherwise, having a plain emergency hard fork might still be a good idea.
+
+### Specification
+
+#### Account State
+
+After the first hard fork using this scheme, the account state stored in the world state trie is changed to become a five-item RLP encoding: `nonce`, `balance`, `storageRoot`, `codeHash` and `version`. The `version` field defines that when a contract call transaction or `CALL` opcode is executed against this contract, which version of the virtual machine should be used. Four-item RLP encoding account state are considered to have the `version` 0.
+
+`CREATE` opcode and the contract creation transaction, however, would only deploy contracts of the newest version.
+
+The behavior of `CALLCODE` and `DELEGATECALL` are not affected by the hard fork -- they would fetch the contract code (even if the contract is deployed in a newer version) and still use the virtual machine version defined in the current contract (or in the case of within the input of contract creation transaction or `CREATE` opcode, the newest virtual machine version) to execute the code.
+
+There is no versioning for precompiled contracts. Once hard fork, they're available for both old and new accounts.
+
+#### Handle Receipts
+
+For simplicity, transaction receipts are always of the newest format, but they should maintain compatibility by either having a default value or allowing null value for newly defined fields. In this way, virtual machines executed in older versions would not need to deal with the new fields in receipts.
+
+### Example
+
+Consider we would like to have the REVERT opcode hard fork in Ethereum Classic using this scheme. After the hard fork, we have:
+
+* Existing accounts are still of four-item RLP encoding. When a transaction has `to` field pointing to them, they're executed using version 0 of EVM. REVERT is the same as INVALID and consumes all the gases.
+* A new contract creation transaction is executed using version 1 virtual machine, and would only create version 1 account on the blockchain. When executing them, it uses version 1 of EVM and REVERT uses the new behavior.
+* When a version 0 account issues a CALL to version 1 account, sub-execution of the version 1 account uses the version 1 virtual machine.
+* When a version 1 account issues a CALL to version 0 account, sub-execution of the version 0 account uses the version 0 vritual machine.
+* When a version 0 account issues a CREATE, it always uses the newest version of the virtual machine, so it only creates version 1 new accounts.
+
+### Discussions
+
+#### Performance
+
+Currently nearly all full node implementations uses config parameters to decide which virtual machine version to use. Switching vitual machine version is simply an operation that changes a pointer using a different set of config parameters. As a result, this scheme has nearly zero impact to performance.
+
+#### Smart Contract Boundary and Formal Verification
+
+Many current efforts are on-going for getting smart contracts formally verified. However, for any hard fork that introduces new opcodes or change behaviors of existing opcodes would break the verification of an existing contract has previously be formally verified. Using the scheme described here, we define the boundary of how a smart contract interacts with the blockchain and it might help the formal verification efforts:
+
+* A smart contract has only immutable access to information of blockchain account balances and codes.
+* A smart contract has only immutable access of block information.
+* A smart contract or a contract creation transaction can modify only its own storage and codes.
+* A smart contract can only interact with the blockchain in a mutable way using `CALL` or `CREATE`.
+
+#### WebAssembly
+
+This scheme can also be helpful when we deploy on-chain WebAssembly virtual machine. In that case, WASM contracts and EVM contracts can co-exist and the execution boundary and interaction model are clearly defined as above.
diff --git a/ECIPs/ECIP-1042.md b/ECIPs/ECIP-1042.md
new file mode 100644
index 00000000..c3121438
--- /dev/null
+++ b/ECIPs/ECIP-1042.md
@@ -0,0 +1,63 @@
+    ECIP: 1042
+    Title: GASPAY opcode
+    Author: Igor Artamonov <splix@etcdevteam.com>
+    Status: Draft
+    Type: Standard
+    Created: 2018-03-08
+    
+# ECIP-1042 - GASPAY opcode    
+    
+# Abstract
+Add an operation to consume gas and add amount paid for that gas to token balance.
+
+# Motivation
+A useful Smart Contract (i.e. valuable) should expect small reward for its execution. A micropayment could be very 
+small a sub-cent payment but sending an additional value to a contract will make it more complicated and cost of such 
+transfer or contract execution could exceed requested reward.
+
+It’s proposed here to introduce a new EVM Operation that will allow a developer to consume a portion of transaction fee 
+(amount paid for a gas) and transfer it to current Smart Contract. 
+
+Using a gas payment provided with transaction provides flexibility and independence from market price of Ether. Gas Price 
+is dynamic value and supposed to represent fair market price of contract execution, therefore making micropayment value 
+proportional to const of transaction and more stable in long term. 
+
+# Specification
+Provide a new operation `GASPAY a` where `a` is amount of gas to consume, and `0x0 <= a <= 0x0fffff`. The payment for 
+that gas goes to contract address. As a return it puts consumed value (Wei) into the stack.
+
+The cost of the operation itself is equal to 1/4 of requested amount of Gas plus 5000 (`a/4 + 5000`). The payment for 
+that gas is going to miner address, and supposed to compensate potential miner loss from including in a block 
+transaction that doesn’t give all gas fee as a reward to a miner.
+
+```
+Op code value: 0x3d
+Mnemonic: GASPAY
+δ: 1
+α: 1
+```
+
+With the current average price of 23000 MWei per Gas, a smart contract can earn up to $1 per operation, by 
+requesting payment for 1,048,575 of Gas.
+
+# Risks consideration
+ 
+## Miners don’t receive payment for all gas in a block
+Currently miners expect that all payment for the gas goes to coinbase. After introducing this operation part of this 
+payment could go to smart contracts participated in block transactions. This plays a role only when we have blocks fully 
+packed with transaction, up to the block gas limit, which is a dynamic value and can be controlled by miners. 
+
+Because cost of the execution of that operation is a constant and roughly is about 5000 of Gas, then requested cost of 
+execution as `a/4 + 5000` will be as much as profitable as including other transactions with same gas limit. With that 
+cost it’s expected that a miner could earn 10%-20% of a requested amount, in addition to cost of actual work spent on 
+execution of that transaction. If gas prices per opcodes are fair, then a miner could be in favour of adding a 
+transaction with GASPAY opcode as it provides slightly more profit to a miner too.
+
+## Software must distinguish payment went to contract and to miner
+Most of the current 3rd party software expect that whole payment for a gas will go to a miner of the block. It includes 
+dev tools, block explorers and nodes (protocol implementations). 
+
+After introducing this new opcode, all this software must be updated according to a new way of gas payment calculation.
+
+## Smart Contract language compilers
+Solidity and other smart contract language compilers will need to be updated to support additional opcode
\ No newline at end of file
diff --git a/ECIPs/ECIP-1043.md b/ECIPs/ECIP-1043.md
new file mode 100644
index 00000000..343da7e8
--- /dev/null
+++ b/ECIPs/ECIP-1043.md
@@ -0,0 +1,37 @@
+```
+ECIP: 
+    Title: Fixed DAG limit restriction 
+    Author: Cody Burns <cody.w.burns@gmail.com>
+    Status: Draft
+    Type: Standard
+    Created: 2018-04-16
+ ```   
+# ECIP-1043 – Fixed DAG limit restriction   
+    
+## Abstract
+The purpose of this ECIP is to set a limit on the maximum size of the DAG to its initial state and no longer increase it on an epoch schedule
+
+## Motivation
+The original intent of the DAG was to provide ASIC resistance to the mining protocol in order to prevent centralization of mining distributions and thereby provide for an objectively fair distribution of tokens. As evident by ASICs being developed that are capable of matching current GPU miners while being more energy efficient, the DAG has failed at its task and now only serves as a deterrent to broader investment in application specific hardware by competent distributors. Because of this, the increasing DAG has began to have negative impact on long term security and acts as an anti-competitive bug preventing large scale investment in mining development .  
+
+As originally discussed in [ECIP-? Limit DAG growth #6](https://github.com/ethereumproject/ECIPs/issues/6) a constantly increasing DAG will eventually reach a hard limit of bus speed on GPU memory and forcing GPU’s into obsolesce does not provide an increase in security. To the contrary, smaller DAG sizes allow more GPU’s the ability to mine while providing a lowered initial entry cost to hobbyist miners.  
+
+A 5 year vision of the mining landscape would see a transition from general purpose GPU mining to a broader market of application specific hardware being built by current and supported by a diverse group of manufactures similar to the current GPU market.
+
+## Specification
+`if(blkNumber > forkblock) DAG epoch = 0`
+
+## Risks consideration
+This ECIP is not forward compatible and introduces backwards incompatibilities in the DAG file generation, block verification, and block mining. Therefore, it should be included in a scheduled hardfork at a certain block number.
+
+This is a long term PRO applicaton specific hardware proposal. If sufficient interest is not generated by manufactures in the mining field, there is risk of domination by one or more manufactures. (market risk)  
+
+## Implementation
+The following clients implemented ECIP
+
+- [] Geth-ETC
+- [] Parity
+- [] Mantis
+
+## Copyright
+Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
diff --git a/ECIPs/ECIP-1044.md b/ECIPs/ECIP-1044.md
new file mode 100644
index 00000000..33231a8a
--- /dev/null
+++ b/ECIPs/ECIP-1044.md
@@ -0,0 +1,84 @@
+### Title
+
+    ECIP: 1044
+    Title: Formalize IPFS hash into ECNS(Ethereum Classic Name Service) resolver
+    Author: Phyrex Tsai <phyrex@portal.network>, Portal Network Team
+    Status: Draft
+    Type: ERC
+    Created: 2018-05-12
+
+# ECIP 1044 - Formalize IPFS hash into ECNS(Ethereum Classic Name Service) resolver
+
+## Simple Summary
+To specify the mapping protocol between resources stored on IPFS and ECNS(Ethereum Classic Name Service).
+
+## Abstract
+The following standard details the implementation of how to combine the IPFS cryptographic hash unique fingerprint with ecns public resolver. This standard provides a functionality to get and set IPFS online resources to ecns resolver.
+  
+We think that this implementation is not only aim to let more developers and communities to provide more use cases, but also leverage the human-readable features to gain more user adoption accessing decentralized resources. We considered the IPFS ecns resolver mapping standard a cornerstone for building future Web3.0 service.
+
+## Motivation
+To build fully decentralized web service, it’s necessary to have a decentralized file storage system. Here comes the IPFS, for three following advantages :
+- Address large amounts of data, and has unique cryptographic hash for every record.
+- Since IPFS is also based on peer to peer network, it can be really helpful to deliver large amounts of data to users, with safer way and lower the millions of cost for the bandwidth.
+- IPFS stores files in high efficient way via tracking version history for every file, and removing the duplications across the network.
+  
+Those features makes perfect match for integrating into ecns, and these make users can easily access content through ecns, and show up in the normal browser.
+
+
+## Specification
+The condition now is that the IPFS file fingerprint using base58 and in the meantime, the Ethereum Classic uses hex in API to encode the binary data. So that need a way to process the condition requires not only we need to transfer from IPFS to Ethereum Classic, but also need to convert it back.
+  
+To solve these requirements, we can use binary buffer bridging that gap.  
+When mapping the IPFS base58 string to ecns resolver, first we convert the Base58 to binary buffer, turn the buffer to hex encrypted format, and save to the contract. Once we want to get the IPFS resources address represented by the specific ecns, we can first find the mapping information stored as hex format before, extract the hex format to binary buffer, and finally turn that to IPFS Base58 address string.
+
+
+## Rationale
+To implement the specification, need two methods from ecns public resolver contract, when we want to store IPFS file fingerprint to contract, convert the Base58 string identifier to the hex format and invoke the `setMultihash` method below :
+  
+```
+function setMultihash(bytes32 node, bytes hash) public only_owner(node);
+```
+  
+Whenever users need to visit the ecns content, we call the `multihash` method to get the IPFS hex data, transfer to the Base58 format, and return the IPFS resources to use.
+  
+```
+function multihash(bytes32 node) public view returns (bytes);
+```
+
+## Test Cases
+
+To implement the way to transfer from base58 to hex format and the reverse one, using the ‘multihashes’ library to deal with the problem.  
+The library link : [https://www.npmjs.com/package/multihashes](https://www.npmjs.com/package/multihashes)  
+To implement the method transfer from IPFS(Base58) to hex format :
+  
+```
+import multihash from 'multihashes'
+
+export const toHex = function(ipfsHash) {
+  let buf = multihash.fromB58String(ipfsHash);
+  return '0x' + multihash.toHexString(buf);
+}
+```
+  
+To implement the method transfer from hex format to IPFS(Base58) :
+  
+```
+import multihash from 'multihashes'
+
+export const toBase58 = function(contentHash) {
+  let hex = contentHash.substring(2)
+  let buf = multihash.fromHexString(hex);
+  return multihash.toB58String(buf);
+}
+```
+
+## Implementation
+The use case can be implemented as browser extension. Users can easily download the extension, and easily get decentralized resources by just typing the ECNS just like we normally type the DNS to browser the website. Solve the current pain for normal people can not easily visit the total decentralized website.
+
+The workable implementation repository : [https://github.com/PortalNetwork/portal-network-browser-extension](https://github.com/PortalNetwork/portal-network-browser-extension)
+
+## Copyright
+Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
+
+
diff --git a/ECIPs/ECIP-1045.md b/ECIPs/ECIP-1045.md
new file mode 100644
index 00000000..df5d1e16
--- /dev/null
+++ b/ECIPs/ECIP-1045.md
@@ -0,0 +1,96 @@
+### ECIP-1045: Support for ETH Byzantium & Constantinople EVM and Protocol Upgrades
+
+    ECIP: 1045/undecided
+    Title: Support for ETH Byzantium & Constantinople EVM and Protocol Upgrades
+    Status: Draft
+    Type: Standard Track
+    Author: Isaac Ardis <isaac@etcdevteam.com>
+    Created: 2018-06-18
+
+### Abstract
+
+Add support for a subset of protocol-impacting changes introduced in the Ethereum Foundation (ETH) network via the _Byzantium_ hardfork. The proposed changes include:
+
+- Byzantium EVM opcodes and precompiled contracts, namely opcodes `REVERT` (EIP 206/140), `RETURNDATASIZE` (EIP 211), `RETURNDATACOPY` (EIP 211), and `STATICCALL` (EIP 214/116); and precompiled contracts for modular exponentiation, elliptic curve addition, scalar multiplication, and pairing (EIPs 198, 212/197, 213/196)
+- Expected Constantinople EVM opcodes, namely bitwise shifting operators `SHL`, `SHR`, and `SAR` (EIP 215); `CREATE2` (EIP 1014); and `EXTCODEHASH` (EIP 1052). 
+	+ TODO: Research and discuss gas metering changes for `SSTORE`, proposed in EIP 1283.
+- Replacing the intermediate state root field in transaction receipts with the contract return status (EIP 658).
+
+This document proposes block `7,100,000` as the upcoming block height at which to implement these changes in the network, placing the expected date of protocol hardfork in January 2019.
+
+For more information on the opcodes and their respective EIPs and implementations, please see the __History__ section of this document.
+
+### Motivation
+
+To enable and maintain interoperability between Foundation and Classic Ethereum Virtual Machines ("EVM"s).
+
+### Specification
+
+As per associated EIPs's specifications and implementations, and success determined by interoperability (implementation) of smart contracts utilizing the introduced opcode and precompiled contracts (implementation before technical specification in case of discrepency).
+
+### Rationale
+
+__Interoperability__: establishing and maintaining interoperable behavior between Ethereum clients is important for developers and end-user adoption, yielding benefits for all participating chains (eg. ETH and ETC). 
+
+__On Immutability__: Introducing new opcodes in the VM has the potential to change behavior of existing contracts; in the case where previously an arbitrary invalid bytecode series (yielding _invalid opcode_) would now be assigned a meaning, and thus could generate or return a value other than _invalid_. In essence, this means "making music where there was only noise before." There is a concern that this behavior change contradicts an essential promise of Immutability, since an existing failing smart contract is liable to become a succeeding (not failing) contract. In counterargument to this concern are two critical points:
+
+1. account states remain changed
+2. the "Homestead" hardfork established a precedent for this type of change, having introduced the `DELEGATECALL` opcode at block 1,150,000.
+
+With these arguments in place, along with precedence and expectation for other continuing and varied consensus-impacting protocol upgrades (eg soft- and hard-forks), it follows that the definition of Immutability is not extended to guarantee perfect consistency for future _behavior_ of historical account states, but only to only to guarantee the immutability of the account states themselves.
+
+### Implementation
+
+Adoption of the content of this ECIP requires a hard fork, and herein that adoption is proposed to be scheduled for block 7,100,000, roughly estimated to arrive in January 2019.
+
+The `ethereumproject/go-ethereum` client implemented an API-only (non-consensus impacting) partial adoption of EIP-658 Transaction status code change via the [v5.5.0](https://github.com/ethereumproject/go-ethereum/releases/tag/v5.5.0) release, and this proposal would augment that change to extend through to the RLP encoding (and thus modify consensus protocol).
+
+### History
+
+##### Byzantium changes
+
+These changes were introduced in the Ethereum Foundation go-ethereum client via the [1.7 "Megara" release](https://github.com/ethereum/go-ethereum/releases/tag/v1.7.0).
+
+These changes were catalogued via the EIP process in the following:
+
+- EIP-658: Transaction receipts embedding status code instead of intermediate state root field - https://github.com/ethereum/EIPs/pull/658
+
+- EIP-140: `REVERT` - https://github.com/ethereum/EIPs/pull/206/files
+
+> The `REVERT` instruction provides a way to stop execution and revert state changes, without consuming all provided gas and with the ability to return a reason.
+
+
+- EIP-211: `RETURNDATASIZE`, `RETURNDATACOPY` - https://github.com/ethereum/EIPs/pull/211/files
+
+> A mechanism to allow returning arbitrary-length data inside the EVM has been requested for quite a while now. Existing proposals always had very intricate problems associated with charging gas. This proposal solves the same problem while at the same time, it has a very simple gas charging mechanism and requires minimal changes to the call opcodes. Its workings are very similar to the way calldata is handled already; after a call, return data is kept inside a virtual buffer from which the caller can copy it (or parts thereof) into memory. At the next call, the buffer is overwritten. This mechanism is 100% backwards compatible.
+
+
+- EIP-214: `STATICCALL` - https://github.com/ethereum/EIPs/pull/214/files
+
+> To increase smart contract security, this proposal adds a new opcode that can be used to call another contract (or itself) while disallowing any modifications to the state during the call (and its subcalls, if present).
+
+- EIP-198: Precompiled contract for modular exponentiation - https://github.com/ethereum/EIPs/pull/198
+
+- EIP-212: Precompiled contract for elliptic curve pairing - https://github.com/ethereum/EIPs/pull/212
+
+- EIP-213: Precompiled contract for elliptic curve addition and scalar multiplication - https://github.com/ethereum/EIPs/pull/213
+
+##### Constantinople changes
+
+These changes are _expected_ to be implemented by the anticipated Constantinople hard fork, which _may_ take place on the ETH network sometime near October 30, 2018, although to date no block number configuration has been accepted to the master branch of the ethereum/go-ethereum client.
+
+- EIP-215:(replacing EIP-145) (https://github.com/ethereum/EIPs/pull/215): Introduce bitwise shifting
+
+> To provide native bitwise shifting with cost on par with other arithmetic operations.
+
+- EIP-1014 (https://github.com/ethereum/EIPs/pull/1247): Use keccak256 name instead of sha3 (`CREATE2`)
+
+> Adds a new opcode at 0xf5, which takes 4 stack arguments: endowment, memory_start, memory_length, salt. Behaves identically to CREATE, except using `keccak256(msg.sender ++ salt ++ init_code)[12:]` instead of the usual sender-and-nonce-hash as the address where the contract is initialized at.
+
+- EIP-1052 (https://github.com/ethereum/EIPs/pull/1052): `EXTCODEHASH` opcode
+
+> Returns the keccak256 hash of a contract's code
+
+
+
+
diff --git a/ECIPs/ECIP-1046.md b/ECIPs/ECIP-1046.md
new file mode 100644
index 00000000..1e6bb903
--- /dev/null
+++ b/ECIPs/ECIP-1046.md
@@ -0,0 +1,89 @@
+### Title
+
+    ECIP: 1046
+    Title: Precompiled contract for verification of Merkle Inclusion Proofs
+    Authors: Kostis Karantias <kkarantias@gmail.com>, Dionysis Zindros <dionyziz@gmail.com>
+    Status: Draft
+    Type: Standard
+    Created: 2018-08-02
+    
+# ECIP 1046 - Precompiled contract for Merkle Inclusion Proofs
+
+## Abstract 
+
+Verification of Merkle Inclusion Proofs is obviously possible in EVM bytecode.
+However, the gas cost for such an operation is very high.
+
+We propose adding this functionality to Ethereum Classic as a precompiled
+contract in order to combat this cost.
+
+## Motivation
+
+Interoperability is a very important goal for Ethereum Classic. We believe that
+having a way to efficiently tell whether a transaction is included in a
+Bitcoin/Bitcoin Cash block by utilizing only the block's Merkle Tree Root and a
+short proof is a great first step in that direction.
+
+Moreover, new efficient constructions which enable cross-chain asset transfers
+like [NIPoPoWs](https://nipopows.com/) heavily rely on Merkle Inclusion Proofs.
+
+## Specification
+
+If `block.number >= MERKLE_FORK_BLKNUM`, add a precompiled contract for Merkle
+Inclusion Proofs (`MERKLEVERIFY`).
+
+The proposal adds a new precompiled function `MERKLEVERIFY` with the following input and output.
+
+`MERKLEVERIFY` takes as **input at least 72 bytes**:
+
+1. **root hash**: the 256-bit merkle tree root hash
+2. **leaf**: the 256-bit leaf we want to prove is included in the merkle tree
+3. **leaf index**: the 64-bit index of the leaf
+4. **siblings**: an array of 256-bit values, arranged from the leaves to the root
+
+`MERKLEVERIFY` returns as **output 4 bytes**:
+
+* `0x00000000` if the proof is valid
+* any non-zero value indicates an invalid proof
+
+### Address
+
+The address of `MERKLEVERIFY` is **`0x9`.**
+
+### Gas costs
+
+Gas cost for `MERKLEVERIFY` is **????**.
+
+## Implementation
+
+The hash function used is `SHA256(SHA256(_))`, to be compatible with Bitcoin/Bitcoin Cash.
+
+The merkle tree construction assumed is described in detail in the [Bitcoin
+Developer Reference](https://bitcoin.org/en/developer-reference#merkle-trees).
+
+Here follows an example implementation of the verification in Solidity:
+
+```solidity
+function merkleVerify(bytes32 root, bytes32 leaf, bytes8 leafIndex, bytes32[] siblings)
+  pure
+  public
+  returns (bool verificationSucceeded)
+{
+  bytes32 h = leaf;
+  for (uint i = 0; i < siblings.length; ++i) {
+    bool siblingOnTheLeft = leafIndex & 0x1 == 1;
+    if (siblingOnTheLeft)
+      h = sha256(abi.encodePacked(sha256(abi.encodePacked(siblings[i], h))));
+    else
+      h = sha256(abi.encodePacked(sha256(abi.encodePacked(h, siblings[i]))));
+    leafIndex >>= 1;
+  }
+  return h == root;
+}
+```
+
+## References
+
+ - [NIPoPoWs](https://nipopows.com/)
+ - [Original Solidity implementation](https://github.com/dionyziz/popow/blob/c82349f870eece524fc027ec787a8b3f3295d566/experiment/contractNipopow.sol#L242-L255)
+ - [Bitcoin Developer Reference](https://bitcoin.org/en/developer-reference#merkle-trees)
diff --git a/ECIPs/ECIP-1050.md b/ECIPs/ECIP-1050.md
new file mode 100644
index 00000000..43a0b8de
--- /dev/null
+++ b/ECIPs/ECIP-1050.md
@@ -0,0 +1,604 @@
+### Title
+
+    ECIP: 1050
+    Title: Status Codes
+    Author: Brooklyn Zelenka [@expede](https://github.com/expede), [Boris Mann](https://github.com/bmann)
+    Discussions-To: https://fission.codes/blockchain/ethclassic
+    Status: Draft
+    Type: Informational
+    Created: 2018-12-03
+
+### Abstract
+
+This standard outlines a common set of Status Codes in the same
+vein as HTTP statuses. This provides a shared set of signals to allow smart contracts
+to react to situations autonomously, expose localized error messages to users, and so on.
+
+The current state of the art is to either `revert` and require human intervention,
+or return a Boolean pass/fail status. Status codes are similar-but-orthogonal
+to `revert`ing with a reason, but aimed at automation and translation.
+
+As is the case with HTTP, having a standard set of known codes has many benefits for developers:
+
+* They remove friction from needing to develop your own schemes for every contract,
+* makes inter-contract automation easier, and
+* makes it easier to broadly understand which of the finite states your request produced.
+
+Importantly, it makes it much easier to distinguish between expected errors states, and truly exceptional conditions that require halting execution.
+
+# Motivation
+
+## Autonomy
+
+Smart contracts are largely intended to be autonomous. While each contract may
+define a specific interface, having a common set of semantic codes can help
+developers write code that can react appropriately to various situations.
+
+## Semantic Density
+
+HTTP status codes are widely used for this purpose. BEAM languages use atoms
+and tagged tuples to signify much the same information. Both provide a lot of
+information both to the programmer (debugging for instance), and to the program
+that needs to decide what to do next.
+
+FISSION Codes convey a much richer set of information than Booleans,
+and are able to be reacted to autonomously unlike arbitrary strings.
+
+## User Feedback
+
+Since status codes are finite and known in advance, we can provide global,
+human-readable sets of status messages. These may also be translated into any language,
+differing levels of technical detail, added as `revert` messages, natspecs, and so on.
+
+We also see a desire for this [in transactions](http://eips.ethereum.org/EIPS/eip-658),
+and there's no reason that FISSION Codes couldn't be used by the EVM itself.
+
+## More than Pass/Fail
+
+While clearly related, status codes are complementary to "revert with reason".
+FISSION Codes are not limited to rolling back the transaction, and may represent known error states
+without halting execution. They may also represent off-chain conditions,
+supply a string to revert, signal time delays, and more.
+
+# Specification
+
+## Format
+
+Codes are returned as the first value of potentially multiple return values.
+
+```js
+// Status only
+
+function isInt(uint num) public pure returns (byte status) {
+    return hex"01";
+}
+
+// Status and value
+
+uint8 private counter;
+
+function safeIncrement(uint8 interval) public returns (byte status, uint8 newCounter) {
+    uint8 updated = counter + interval;
+
+    if (updated >= counter) {
+        counter = updated;
+        return (hex"01", updated);
+    } else {
+        return (hex"00", counter);
+    }
+}
+```
+
+In the rare case that there are multiple codes required to express an idea,
+they should be organized in ascending order.
+
+# Code Table
+
+| X. Low Nibble                     | 0. Generic              | 10. Permission                | 20. Find/Match/&c       | 30. Negotiation / Offers         | 40. Availability                 | 50. | 60. | 70. | 80. | 90. | A0. | B0. | C0. | D0. | E0. Cryptography                    | F0. Off Chain                                     |
+|-----------------------------------|-------------------------|-------------------------------|-------------------------|----------------------------------|----------------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-------------------------------------|---------------------------------------------------|
+| 0. Failure                        | 0x00 Failure            | 0x10 Disallowed               | 0x20 Not Found          | 0x30 Other Party Disagreed       | 0x40 Unavailable or Expired      |     |     |     |     |     |     |     |     |     | 0xE0 Decrypt Failure                | 0xF0 Off Chain Failure                            |
+| 1. Success                        | 0x01 Success            | 0x11 Allowed                  | 0x21 Found              | 0x31 Other Party Agreed          | 0x41 Available                   |     |     |     |     |     |     |     |     |     | 0xE1 Decrypt Success                | 0xF1 Off Chain Success                            |
+| 2. Accepted / Started             | 0x02 Accepted / Started | 0x12 Requested Permission     | 0x22 Match Request Sent | 0x32 Sent Offer                  |                                  |     |     |     |     |     |     |     |     |     | 0xE2 Signed                         | 0xF2 Off Chain Process Started                    |
+| 3. Awaiting Others                | 0x03 Awaiting           | 0x13 Awaiting Permission      | 0x23 Awaiting Match     | 0x33 Awaiting Their Ratification | 0x43 Not Yet Available           |     |     |     |     |     |     |     |     |     | 0xE3 Other Party Signature Required | 0xF3 Awaiting Off Chain Completion                |
+| 4. Action Required / Awaiting You | 0x04 Action Required    | 0x14 Awaiting Your Permission |                         | 0x34 Awaiting Your Ratification  | 0x44 Awaiting Your Availability* |     |     |     |     |     |     |     |     |     | 0xE4 Your Signature Required        | 0xF4 Off Chain Action Required                    |
+| 5.                                |                         |                               |                         |                                  |                                  |     |     |     |     |     |     |     |     |     |                                     |                                                   |
+| 6.                                |                         |                               |                         |                                  |                                  |     |     |     |     |     |     |     |     |     |                                     |                                                   |
+| 7.                                |                         |                               |                         |                                  |                                  |     |     |     |     |     |     |     |     |     |                                     |                                                   |
+| 8.                                |                         |                               |                         |                                  |                                  |     |     |     |     |     |     |     |     |     |                                     |                                                   |
+| 9.                                |                         |                               |                         |                                  |                                  |     |     |     |     |     |     |     |     |     |                                     |                                                   |
+| A.                                |                         |                               |                         |                                  |                                  |     |     |     |     |     |     |     |     |     |                                     |                                                   |
+| B.                                |                         |                               |                         |                                  |                                  |     |     |     |     |     |     |     |     |     |                                     |                                                   |
+| C.                                |                         |                               |                         |                                  |                                  |     |     |     |     |     |     |     |     |     |                                     |                                                   |
+| D.                                |                         |                               |                         |                                  |                                  |     |     |     |     |     |     |     |     |     |                                     |                                                   |
+| E.                                |                         |                               |                         |                                  |                                  |     |     |     |     |     |     |     |     |     |                                     |                                                   |
+| F. Meta/Info                      | 0x0F Metadata Only      |                               |                         |                                  |                                  |     |     |     |     |     |     |     |     |     |                                     | 0xFF Data Source is Off Chain (ie: no guarantees) |
+
+* Unused regions are available for further extension or custom codes
+* You may need to scroll the tables horizontally (they're pretty wide)
+
+
+Codes break nicely into a 16x16 matrix, represented as a 2-digit hex number.
+The high nibble represents the code's kind or "category", and the low nibble contains
+the state or "reason". We present them below as separate tables per range for
+explanatory and layout reasons.
+
+Unspecified codes are _not_ free for arbitrary use, but rather open for further specification.
+
+## Generic
+
+General codes. These double as bare "reasons", since `0x01 == 1`.
+
+|  Code           | Description             |
+|-----------------|:------------------------|
+| `0x00`          | Failure                 |
+| `0x01`          | Success                 |
+| `0x02`          | Accepted / Started      |
+| `0x03`          | Awaiting / Before       |
+| `0x04`          | Action Required         |
+| `0x05`          | Expired                 |
+| `0x06`          |                         |
+| `0x07`          |                         |
+| `0x08`          |                         |
+| `0x09`          |                         |
+| `0x0A`          |                         |
+| `0x0B`          |                         |
+| `0x0C`          |                         |
+| `0x0D`          |                         |
+| `0x0E`          |                         |
+| `0x0F`          | Meta or Info Only       |
+
+## Permission
+
+Related to permisson, authorization, approval, and so on.
+
+|  Code           | Description              |
+|-----------------|:-------------------------|
+| `0x10`          | Disallowed               |
+| `0x11`          | Allowed                  |
+| `0x12`          | Requested Permission     |
+| `0x13`          | Awaiting Permission      |
+| `0x14`          | Awaiting Your Permission |
+| `0x15`          | No Longer Allowed        |
+| `0x16`          |                          |
+| `0x17`          |                          |
+| `0x18`          |                          |
+| `0x19`          |                          |
+| `0x1A`          |                          |
+| `0x1B`          |                          |
+| `0x1C`          |                          |
+| `0x1D`          |                          |
+| `0x1E`          |                          |
+| `0x1F`          | Permission Meta or Info  |
+
+## Find, Match, &c
+
+This range is broadly intended for finding and matching.
+Data lookups and order matching are two common use cases.
+
+|  Code           | Description              |
+|-----------------|:-------------------------|
+| `0x20`          | Not Found                |
+| `0x21`          | Found                    |
+| `0x22`          | Match Request Sent       |
+| `0x23`          | Awaiting Match           |
+| `0x24`          | Match Request Received   |
+| `0x25`          | Out of Range             |
+| `0x26`          |                          |
+| `0x27`          |                          |
+| `0x28`          |                          |
+| `0x29`          |                          |
+| `0x2A`          |                          |
+| `0x2B`          |                          |
+| `0x2C`          |                          |
+| `0x2D`          |                          |
+| `0x2E`          |                          |
+| `0x2F`          | Matching Meta or Info    |
+
+## Negotiation, Terms, and Offers
+
+Negotiation, and very broadly the flow of such transactions.
+Note that "other party" may be more than one actor (not necessarily the sender).
+
+|  Code           | Description                 |
+|-----------------|:----------------------------|
+| `0x30`          | Other Party Disagreed       |
+| `0x31`          | Other Party Agreed          |
+| `0x32`          | Sent Offer                  |
+| `0x33`          | Awaiting Their Ratification |
+| `0x34`          | Awaiting Your Ratification  |
+| `0x35`          | Offer Expired               |
+| `0x36`          |                             |
+| `0x37`          |                             |
+| `0x38`          |                             |
+| `0x39`          |                             |
+| `0x3A`          |                             |
+| `0x3B`          |                             |
+| `0x3C`          |                             |
+| `0x3D`          |                             |
+| `0x3E`          |                             |
+| `0x3F`          | Negotiation Meta or Info    |
+
+## Availability
+
+Service or action availability.
+
+|  Code           | Description                 |
+|-----------------|:----------------------------|
+| `0x40`          | Unavailable                 |
+| `0x41`          | Available                   |
+| `0x42`          | You May Begin               |
+| `0x43`          | Not Yet Available           |
+| `0x44`          | Awaiting Your Availability  |
+| `0x45`          | No Longer Available         |
+| `0x46`          |                             |
+| `0x47`          |                             |
+| `0x48`          |                             |
+| `0x49`          |                             |
+| `0x4A`          |                             |
+| `0x4B`          |                             |
+| `0x4C`          |                             |
+| `0x4D`          |                             |
+| `0x4E`          |                             |
+| `0x4F`          | Availability Meta or Info   |
+
+### `0x5_` TBD
+
+Currently unspecified
+
+### `0x6_` TBD
+
+Currently unspecified
+
+### `0x7_` TBD
+
+Currently unspecified
+
+### `0x8_` TBD
+
+Currently unspecified
+
+### `0x9_` TBD
+
+Currently unspecified
+
+## Application-Specific Codes
+
+Contracts may have special states that they need to signal.
+This proposal only outlines the broadest meanings, but implementers may have very
+specific meanings for each, as long as they are coherent with the broader definition.
+
+|  Code           | Description                     |
+|-----------------|:--------------------------------|
+| `0xA0`          | App-Specific Failure            |
+| `0xA1`          | App-Specific Success            |
+| `0xA2`          | App-Specific Acceptance / Start |
+| `0xA3`          | App-Specific Awaiting / Before  |
+| `0xA4`          | App-Specific Action Required    |
+| `0xA5`          | App-Specific Expiry             |
+| `0xA6`          |                                 |
+| `0xA7`          |                                 |
+| `0xA8`          |                                 |
+| `0xA9`          |                                 |
+| `0xAA`          |                                 |
+| `0xAB`          |                                 |
+| `0xAC`          |                                 |
+| `0xAD`          |                                 |
+| `0xAE`          |                                 |
+| `0xAF`          | App-Specific Meta or Info       |
+
+### `0xB_` TBD
+
+Currently unspecified
+
+### `0xC_` TBD
+
+Currently unspecified
+
+### `0xD_` TBD
+
+Currently unspecified
+
+## Cryptography and Authentication
+
+Actions around signatures, cryptography, signing, and application-level authentication.
+
+The meta code `0xEF` is often used to signal a payload descibing the algorithm
+or process used.
+
+|  Code           | Description                 |
+|-----------------|:----------------------------|
+| `0xE0`          | Decrypt Failure             |
+| `0xE1`          | Decrypt Success             |
+| `0xE2`          | Signed                      |
+| `0xE3`          | Their Signature Required    |
+| `0xE4`          | Your Signature Required     |
+| `0xE5`          | Auth Expired                |
+| `0xE6`          |                             |
+| `0xE7`          |                             |
+| `0xE8`          |                             |
+| `0xE9`          |                             |
+| `0xEA`          |                             |
+| `0xEB`          |                             |
+| `0xEC`          |                             |
+| `0xED`          |                             |
+| `0xEE`          |                             |
+| `0xEF`          | Crypto Info or Meta         |
+
+## `0xF0` Off-Chain
+
+For off-chain actions. Much like th `0x0_: Generic` range, `0xF_` is very general,
+and does little to modify the reason.
+
+Among other things, the meta code `0xFF` may be used to describe what the off-chain process is.
+
+|  Code           | Description                   |
+|-----------------|:------------------------------|
+| `0xF0`          | Off-Chain Failure             |
+| `0xF1`          | Off-Chain Success             |
+| `0xF2`          | Off-Chain Process Stared      |
+| `0xF3`          | Awaiting Off-Chain Completion |
+| `0xF4`          | Off-Chain Action Required     |
+| `0xF5`          | Off-Chain Service Unavailable |
+| `0xF6`          |                               |
+| `0xF7`          |                               |
+| `0xF8`          |                               |
+| `0xF9`          |                               |
+| `0xFA`          |                               |
+| `0xFB`          |                               |
+| `0xFC`          |                               |
+| `0xFD`          |                               |
+| `0xFE`          |                               |
+| `0xFF`          | Off-Chain Info or Meta        |
+
+### Example Function Change
+
+```js
+uint256 private startTime;
+mapping(address => uint) private counters;
+
+// Before
+function increase() public returns (bool _available) {
+    if (now < startTime && counters[msg.sender] == 0) {
+        return false;
+    };
+
+    counters[msg.sender] += 1;
+    return true;
+}
+
+// After
+function increase() public returns (byte _status) {
+    if (now < start) { return hex"43"; } // Not yet available
+    if (counters[msg.sender] == 0) { return hex"10"; } // Not authorized
+
+    counters[msg.sender] += 1;
+    return hex"01"; // Success
+}
+```
+
+### Example Sequence Diagrams
+
+```
+0x03 = Waiting
+0x31 = Other Party (ie: not you) Agreed
+0x41 = Available
+0x43 = Not Yet Available
+
+
+                          Exchange
+
+
+AwesomeCoin                 DEX                     TraderBot
+     +                       +                          +
+     |                       |       buy(AwesomeCoin)   |
+     |                       | <------------------------+
+     |         buy()         |                          |
+     | <---------------------+                          |
+     |                       |                          |
+     |     Status [0x43]     |                          |
+     +---------------------> |       Status [0x43]      |
+     |                       +------------------------> |
+     |                       |                          |
+     |                       |        isDoneYet()       |
+     |                       | <------------------------+
+     |                       |                          |
+     |                       |       Status [0x43]      |
+     |                       +------------------------> |
+     |                       |                          |
+     |                       |                          |
+     |     Status [0x41]     |                          |
+     +---------------------> |                          |
+     |                       |                          |
+     |       buy()           |                          |
+     | <---------------------+                          |
+     |                       |                          |
+     |                       |                          |
+     |     Status [0x31]     |                          |
+     +---------------------> |      Status [0x31]       |
+     |                       +------------------------> |
+     |                       |                          |
+     |                       |                          |
+     |                       |                          |
+     |                       |                          |
+     +                       +                          +
+```
+
+
+
+```
+0x01 = Generic Success
+0x10 = Disallowed
+0x11 = Allowed
+
+                                              Token Validation
+
+
+           Buyer                  RegulatedToken           TokenValidator               IDChecker          SpendLimiter
+             +                          +                         +                         +                   +
+             |        buy()             |                         |                         |                   |
+             +------------------------> |          check()        |                         |                   |
+             |                          +-----------------------> |          check()        |                   |
+             |                          |                         +-----------------------> |                   |
+             |                          |                         |                         |                   |
+             |                          |                         |         Status [0x10]   |                   |
+             |                          |       Status [0x10]     | <-----------------------+                   |
+             |        revert()          | <-----------------------+                         |                   |
+             | <------------------------+                         |                         |                   |
+             |                          |                         |                         |                   |
++---------------------------+           |                         |                         |                   |
+|                           |           |                         |                         |                   |
+| Updates ID with provider  |           |                         |                         |                   |
+|                           |           |                         |                         |                   |
++---------------------------+           |                         |                         |                   |
+             |                          |                         |                         |                   |
+             |         buy()            |                         |                         |                   |
+             +------------------------> |        check()          |                         |                   |
+             |                          +-----------------------> |         check()         |                   |
+             |                          |                         +-----------------------> |                   |
+             |                          |                         |                         |                   |
+             |                          |                         |       Status [0x11]     |                   |
+             |                          |                         | <-----------------------+                   |
+             |                          |                         |                         |                   |
+             |                          |                         |                         |   check()         |
+             |                          |                         +-------------------------------------------> |
+             |                          |                         |                         |                   |
+             |                          |                         |                         |  Status [0x11]    |
+             |                          |       Status [0x11]     | <-------------------------------------------+
+             |        Status [0x01]     | <-----------------------+                         |                   |
+             | <------------------------+                         |                         |                   |
+             |                          |                         |                         |                   |
+             |                          |                         |                         |                   |
+             |                          |                         |                         |                   |
+             +                          +                         +                         +                   +
+```
+
+# Rationale
+
+## Encoding
+
+Status Codes are encoded as a `byte`. Hex values break nicely into high and low nibbles:
+`category` and `reason`. For instance, `hex"01"` stands for general success
+and `hex"00"` for general failure.
+
+`byte` is quite lightweight, and can be easily packed with multiple codes into
+a `bytes32` (or similar) if desired. It is also easily interoperable with `uint8`,
+cast from `enum`s, and so on.
+
+## Alternatives
+
+Alternate schemes include `bytes32` and `uint8`. While these work reasonably
+well, they have drawbacks.
+
+`uint8` feels even more similar to HTTP status codes, and enums don't require
+as much casting. However does not break as evenly as a square table
+(256 doesn't look as nice in base 10).
+
+Packing multiple codes into a single `bytes32` is nice in theory, but poses additional
+challenges. Unused space may be interpeted as `0x00 Failure`, you can only efficiently
+pack four codes at once, and there is a challenge in ensuring that code combinations
+are sensible. Forcing four codes into a packed representation encourages multiple
+status codes to be returned, which is often more information than strictly nessesary.
+This can lead to paradoxical results (ex `0x00` and `0x01` together),
+or greater resorces allocated to interpreting 256<sup>4</sup> (4.3 billion) permutations.
+
+## Multiple Returns
+
+While there may be cases where packing a byte array of FISSION Codes may make sense, the simplest,
+most forwards-compatible method of transmission is as the first value of a multiple return.
+
+Familiarity is also a motivating factor. A consistent position and encoding together
+follow the principle of least surprise. It is both viewable as a "header" in the HTTP analogy,
+or like the "tag" in BEAM tagged tupples.
+
+## Human Readable
+
+Developers should not be required to memorize 256 codes. However, they break nicely into a table.
+Cognitive load is lowered by organizing the table into categories and reasons.
+`0x10` and `0x11` belong to the same category, and `0x04` shares a reason with `0x24`
+
+While this repository includes helper enums, we have found working directly in
+the hex values to be quite natural. ESC `0x10` is just as comfortable as HTTP 401, for example.
+
+## Extensiblilty
+
+The `0xA` category is reserved for application-specific statuses.
+In the case that 256 codes become insufficient, `bytes1` may be embedded in larger byte arrays.
+
+## EVM Codes
+
+The EVM also returns a status code in transactions; specifically `0x00` and `0x01`.
+This proposal both matches the meanings of those two codes, and could later be used
+at the EVM level.
+
+## Empty Space
+
+Much like how HTTP status codes have large unused ranges, there are totally empty
+sections in this proposal. The intent is to not impose a complete set of codes up front,
+and to allow users to suggest uses for these spaces as time progresses.
+
+## Nibble Order
+
+Nibble order makes no difference to the machine, and is purely mnemonic.
+This design was originally in opposite order, but changed it for a few convenience factors.
+Since it's a different scheme from HTTP, it may feel strange initially,
+but becomes very natural after a couple hours of use.
+
+## Short Forms
+
+Generic is `0x0_`, general codes are consistent with their integer representations
+
+```js
+hex"1" == hex"01" == 1 // with casting
+```
+
+## Contract Categories
+
+Many applications will always be part of the same category.
+For instance, validation will generally be in the `0x10` range.
+
+```js
+contract Whitelist {
+    mapping(address => bool) private whitelist;
+    uint256 private deadline;
+    byte constant private prefix = hex"10";
+
+    check(address _, address _user) returns (byte _status) {
+        if (now >= deadline)  { return prefix | 5; }
+        if (whitelist[_user]) { return prefix | 1; }
+        return prefix;
+    }
+}
+```
+
+## Helpers
+
+This above also means that working with app-specific enums is slightly easier:
+
+```js
+enum Sleep {
+    Awake,
+    Asleep,
+    REM,
+    FallingAsleep
+}
+
+// From the helper library
+
+function appCode(Sleep _state) returns (byte code) {
+    return byte(160 + _state); // 160 = 0xA0
+}
+
+// Versus
+
+function appCode(Sleep _state) returns (byte code) {
+    return byte((16 * _state) + 10); // 10 = 0xA
+}
+```
+
+# Implementation
+
+Reference cases and helper libraries (Solidity and JS) can be found at:
+
+* [Source Code](https://github.com/fission-suite/fission-codes)
+* [Package on npm](https://www.npmjs.com/package/fission-codes)
+
diff --git a/ECIPs/ECIP-1051.md b/ECIPs/ECIP-1051.md
new file mode 100644
index 00000000..d1f296e0
--- /dev/null
+++ b/ECIPs/ECIP-1051.md
@@ -0,0 +1,51 @@
+```
+ECIP: 1051
+Title: Ethereum Classic Treasury system
+Status: Draft
+Type: Standard Track - Consensus
+Author: Dexaran, dexaran@ethereumclassic.org
+Created: 2018-12-31
+```
+
+## Abstract
+
+The following describes the possible implementation of a development funding mechanism.
+
+## Motivation
+
+The crypto industry is actively developing. This also applies to Ethereum Classic. In order for the development of the project to continue it is necessary to incentivize developers to take part in it. Having a professional development team also requires a permanent source of funding.
+
+We have a [precedent of one of the main ETC development teams being shutdown due to lack of funding](https://ethereumworldnews.com/ethereum-classic-etc-development-team-shuts-down-operations-due-to-funding/). ([announcement reference](https://twitter.com/etcdev/status/1069625401515872256?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1069625401515872256&ref_url=https%3A%2F%2Fwww.cryptoglobe.com%2Flatest%2F2018%2F12%2Fleading-ethereum-classic-dev-team-quits-due-to-lack-of-funds%2F))
+
+[Ethereum Commonwealth](https://github.com/EthereumCommonwealth), the other ETC development team, adheres to the [policy of financial transparency](https://github.com/EthereumCommonwealth/Roadmap/issues/27). According to our public financial report, you can see that we did not receive any funding since July 2017 to the end of 2018.
+
+Summarizing the above, I can conclude that a permanent source of development funding is essential for further growth and maintenance of the project and ecosystem. This source of funding should be implemented at the protocol level.
+
+The source of funding must ensure: 
+- *financial transparency* - this is ensured by the ability to track transactions.
+- *constant cash flow* which must be used to incentivize contributors to develop Ethereum Classic core OR ecosystem.
+- *agnosticism* - third party contributors must have access to the source of funding even if they never contributed to ETC development before.
+
+## Specification
+
+#### General
+
+The proposed solution is based on [Callisto Network Treasury](https://whitepaper.io/document/345/callisto-network-whitepaper).
+
+Callisto Network Treasury advantages:
+
+1. Has a working implementation ([geth](https://github.com/EthereumCommonwealth/go-callisto) / [parity](https://github.com/EthereumCommonwealth/rust-callisto)) 
+2. [Already tested](https://callisto.network/financial-report/) in real market environment.
+3. Simple and secure to implement/rollback.
+4. Compatible with ECIP-1017: ETC monetary policy.
+
+#### Technical
+
+The proposed treasury system relies on two system addresses that receive funding at the protocol level. The protocol-level funding is a split of a base block reward. When a new block is mined, the reward is represented by three values: miner's block reward, `X` and `Y` where:
+
+- `X` goes to the first Treasury address.
+- `Y` goes to the second Treasury address.
+- `(base block reward - (X + Y))` goes to miner's address.
+
+This is possible to implement the described scheme without changing the `base block reward`, thus keeping the original 5M20 Ethereum Classic monetary policy unaffected.
+
diff --git a/ECIPs/ECIP-1052.md b/ECIPs/ECIP-1052.md
new file mode 100644
index 00000000..de843078
--- /dev/null
+++ b/ECIPs/ECIP-1052.md
@@ -0,0 +1,75 @@
+```
+ECIP: 1052
+Title: Smart-contract Security Auditing core
+Status: Draft
+Type: Meta
+Author: Dexaran, dexaran@ethereumclassic.org
+Created: 2018-12-31
+```
+
+## Abstract
+
+The following describes a smart-contract development security enhancement method, its implementation and the underlying funding mechanism as well as a possible unique feature and use case of Ethereum CLassic project.
+
+## Motivation
+
+[Smart-contract development security](https://en.wikipedia.org/wiki/Software_development_security) is critical for the whole crypto industry and for Ethereum Classic in particular. We know the precedents of large contract hacks, which led to the loss of large amounts of funds as well as undermining confidence in the industry as a whole. For example [TheDAO hack](https://en.wikipedia.org/wiki/The_DAO_(organization)), [Parity Multisig hack 1](https://blog.zeppelin.solutions/on-the-parity-wallet-multisig-hack-405a8c12e8f7), [Parity Multisig hack 2](https://medium.com/chain-cloud-company-blog/parity-multisig-hack-again-b46771eaa838), [ERC20 vulnerability led to the loss of millions of dollars](https://medium.com/@dexaran820/previously-described-at-erc20-critical-problems-medium-article-db616c84acc1).
+
+As an information security engineer, I can say that formal verification, better coding standards, new programming languages, and other automated tools cannot significantly improve the fault-tolerance of smart contract systems.
+
+On the other hand, the smart contracting industry still needs security improvements and decentralized, immutable, chain-agnostic environment which will ensure and preserve contract development/auditing history. I propose to establish a team of professional security auditors that will work to enhance the security of smart-contracts (for ETC or for the whole industry).
+
+Advantages:
+
+- ETC is definitely a proper immutable, decentralized, chain-agnostic environment which can serve the above goal.
+- ETC benefits from smart-contract security enhancement too, as ETC is a smart-contract development platform.
+- The total value of the entire cryptoindustry rises, which is also benefitial for ETC.
+- Unique use case for Ethereum CLassic blockchain, which can increase the network effect and boost the growth of the project and ecosystem.
+
+## Specification
+
+We must not rely on blockchain technology to verify smart-contracts. We can only use it to provide a registry of audited contracts, publish and manage results of smart-contract audits.
+
+#### Security auditing team
+
+![alt text](https://github.com/Dexaran/Security-DAO-registry/blob/master/Audit_Reg_Flow.png)
+
+The detailed description of Security Auditing organization can be found here: https://github.com/EthereumCommonwealth/Auditing
+
+There are two types of participants in the described organization: [managers](https://github.com/Dexaran/Security-DAO/blob/master/SecurityDAO.sol#L17) and [auditors](https://github.com/Dexaran/Security-DAO/blob/master/SecurityDAO.sol#L11-L18).
+
+The main task of a manager is to control and verify the work of the auditors.
+
+The main task of an auditor is to review a code of smart-contracts and submit [reports](https://github.com/Dexaran/Security-DAO/blob/master/SecurityDAO.sol#L29-L40). Auditors receive [karma](https://github.com/Dexaran/Security-DAO/blob/master/SecurityDAO.sol#L15) for reviewing contracts. They also receive [penalties](https://github.com/Dexaran/Security-DAO-registry/blob/master/SecurityDAO.sol#L17) for making mistakes. The statistic reflects each auditors results and determines their reward.
+
+The audit process will be managed through github so that it will be transparently available for everyone. A smart-contract developer should open an [issue](https://github.com/Dexaran/Security-DAO/issues) to submit his smart-contract for auditors review. Then the manager will verify security audit request details and mark the issue as *approved*. The manager should not mark dummy requests, requests that aim to spam the security audit queue or any requests that does not met coding standard requirements. After that, **every** auditor can start reviewing the code. 
+
+An auditor with a willingness to participate in the code review of a certain contract must create a [private gist](https://gist.github.com/) and send gist URL to the corresponding issue manager by [email](https://github.com/Dexaran/Security-DAO/blob/master/SecurityDAO.sol#L14). E-mail address of each manager or auditor is transparently available at the smart-contract of this organization.
+
+#### Security Auditing organization governance.
+
+Currently, the security auditing organization relies on [Treasury proposal](https://github.com/ethereumclassic/ECIPs/issues/4) and rights delegation mechanism.
+
+1. Treasury voters owners establish the payment schedule for security auditing department, thus delegate the governance rights to the security auditing manager.
+
+2. Security auditing manager distributes the received payment between the auditing team members.
+
+3. If Treasury voters are not satisfied by the workflow of security department then they must fire the security auditing manager.
+
+It is planned to automate the security auditing team workflow with a [SecurityDAO smart-contract](https://github.com/Dexaran/Security-DAO-registry) in 2019 however the contract is still in development. Security DAO smart-contract is not a critically important detail of this proposal.
+
+#### Outcome
+
+As the result of the functioning system we receive a well-defined process of smart-contract security auditing. Each smart-contract is reviewed by at least 3 professional security auditors.
+Security audits are completely free-of-charge for smart-contract developers, thus every smart-contract developer is capable of ordering a security audit before deploying his/her smart-contract.
+
+- Security Auditing organization structure has a working implementation in Callisto Network.
+
+- [113 succesful security audits](https://github.com/EthereumCommonwealth/Auditing/issues?q=is%3Aissue+is%3Aclosed) were performed during 2018.
+
+- According to Callisto Network statistics for 2018, this costs the ecosystem approx. $4000/month. I think that this is a reasonable price which should be paid to prevent such accidents as TheDAO hack and other hacks which caused much more losses.
+
+#### Requirements
+
+This requires [Treasury Proposal](https://github.com/ethereumclassic/ECIPs/issues/4) implementation.
+
diff --git a/README.md b/README.md
index 1aaad0e0..d17e1171 100644
--- a/README.md
+++ b/README.md
@@ -2,6 +2,31 @@
 
 [![Join the chat at https://gitter.im/ethereumproject/ECIPs](https://badges.gitter.im/ethereumproject/ECIPs.svg)](https://gitter.im/ethereumproject/ECIPs?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
 
+# Current ECIPs
+
+| Number        | Title        | Author | Type  | Layer        | Status / Discussion |
+| ------------- | ------------ | ------ | ----- | -------------| ------------------- |
+| [ECIP-1010](ECIPs/ECIP-1010.md) | Delay Difficulty Bomb Explosion | Igor Artamonov | Standard | Consensus (hard-fork) | [Accepted](https://github.com/ethereumproject/ECIPs/issues/4) |
+| [ECIP-1013](ECIPs/ECIP-1013.md) | ETC On-Chain Cryptographic Signing and Authentication Protocol | Cody W Burns | Standard | Meta | Draft |
+| [ECIP-1017](ECIPs/ECIP-1017.md) | Monetary Policy and Final Modification to the Ethereum Classic Emission Schedule | Matthew Mazur | Standard | Consensus (hard-fork) | Accepted |
+| [ECIP-1021](ECIPs/ECIP-1021.md) | ERC223 Token Standard | Dexaran | Standard | ERC | Draft |
+| [ECIP-1022](ECIPs/ECIP-1022.md) | Generalized Version Bits Voting for Consensus Soft and Hard Forks | Wei Tang | Standard | Informational | Draft |
+| [ECIP-1023](ECIPs/ECIP-1023.md) | Combined CarbonVote and MinerVote for Consensus Soft and Hard Forks | Wei Tang | Standard | Informational | Draft |
+| [ECIP-1030](ECIPs/ECIP-1030.md) | Defining the SYSTEM Transaction | Wei Tang | Standard | Meta | Draft |
+
+# EIPs that applies to Ethereum Classic network
+
+| Number        | Title        | Author | Type  | Layer        | Status / Discussion |
+| ------------- | ------------ | ------ | ----- | -------------| ------------------- |
+| [EIP-2](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2.mediawiki) | Homestead Hard-fork Changes | Vitalik Buterin | Standard | Consensus (hard-fork) | Final |
+| [EIP-7](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7.md) | DELEGATECALL | Vitalik Buterin | Standard | Consensus (hard-fork) | Final |
+| [EIP-8](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-8.md) | devp2p Forward Compatibility Requirements for Homestead | Felix Lange | Standard | Networking | Final |
+| [EIP-141](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-141.md) | Designated invalid EVM instruction | Alex Beregszaszi | Standard | Consensus | Final |
+| [EIP-150](https://github.com/ethereum/EIPs/issues/150) | Long-term gas cost changes for IO-heavy operations | Vitalik Buterin | Standard | Consensus (hard-fork) | Final |
+| [EIP-155](https://github.com/ethereum/EIPs/issues/155) | Simple replay attack protection | Vitalik Buterin | Standard | Consensus (hard-fork) | Final |
+| [EIP-160](https://github.com/ethereum/EIPs/issues/160) | EXP cost increase | Vitalik Buterin | Standard | Consensus (hard-fork) | Final |
+
+
 Ethereum Classic Improvement Proposals (ECIPs), are technical write-ups that describe suggested changes to the Ethereum Protocol. Finalized proposals agreed up by volunteer client developers, and the users of the Ethereum Classic main net blockchain are implemented by Ethereum Classic client developers.
 
 Every pull request will be reviewed and discussed by volunteer Ethereum Classic client developers and any developers on Github willing to contribute their well reasoned opinions. Regardless if there is general agreement you are able to use the information generated from the discussion to create a second draft. This can be done by either updating the pull request or submitting a new pull request. This process can be repeated (See figure 1) until the volunteer developer community agrees to add the pull request.
@@ -23,24 +48,3 @@ Decentralized decision making is part of the in-depth security that protects the
 # Getting started contributing
 The [ECIP sample](./ECIP-1.sample.md) is the best place to start. The sample was updated for Ethereum use by Martin Becze, it was predominantly derived from the Bitcoin improvement proposal based on the Python improvement proposal system. Fork the repository and add your ECIP to it, using the provided [ECIP markdown template](./ECIP-number.template.md). Submit by creating a Pull Request to the Ethereum Classic [ECIPs repository](https://github.com/ethereumclassic/ECIPs).
 
-# Current ECIPs
-
-| Number        | Title        | Author | Type  | Layer        | Status / Discussion |
-| ------------- | ------------ | ------ | ----- | -------------| ------------------- |
-| [ECIP-1010](ECIPs/ECIP-1010.md) | Delay Difficulty Bomb Explosion | Igor Artamonov | Standard | Consensus (hard-fork) | [Accepted](https://github.com/ethereumproject/ECIPs/issues/4) |
-| [ECIP-1013](ECIPs/ECIP-1013.md) | ETC On-Chain Cryptographic Signing and Authentication Protocol | Cody W Burns | Standard | Meta | Draft |
-| [ECIP-1017](ECIPs/ECIP-1017.md) | Monetary Policy and Final Modification to the Ethereum Classic Emission Schedule | Matthew Mazur | Standard | Consensus (hard-fork) | Final |
-| [ECIP-1021](ECIPs/ECIP-1021.md) | ERC223 Token Standard | Dexaran | Standard | ERC | Draft |
-| [ECIP-1030](ECIPs/ECIP-1030.md) | Defining the SYSTEM Transaction | Wei Tang | Standard | Meta | Draft |
-
-# EIPs that applies to Ethereum Classic network
-
-| Number        | Title        | Author | Type  | Layer        | Status / Discussion |
-| ------------- | ------------ | ------ | ----- | -------------| ------------------- |
-| [EIP-2](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2.mediawiki) | Homestead Hard-fork Changes | Vitalik Buterin | Standard | Consensus (hard-fork) | Final |
-| [EIP-7](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7.md) | DELEGATECALL | Vitalik Buterin | Standard | Consensus (hard-fork) | Final |
-| [EIP-8](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-8.md) | devp2p Forward Compatibility Requirements for Homestead | Felix Lange | Standard | Networking | Final |
-| [EIP-141](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-141.md) | Designated invalid EVM instruction | Alex Beregszaszi | Standard | Consensus | Final |
-| [EIP-150](https://github.com/ethereum/EIPs/issues/150) | Long-term gas cost changes for IO-heavy operations | Vitalik Buterin | Standard | Consensus (hard-fork) | Final |
-| [EIP-155](https://github.com/ethereum/EIPs/issues/155) | Simple replay attack protection | Vitalik Buterin | Standard | Consensus (hard-fork) | Final |
-| [EIP-160](https://github.com/ethereum/EIPs/issues/160) | EXP cost increase | Vitalik Buterin | Standard | Consensus (hard-fork) | Final |

From c95e313514cf7e2646d6158072ed6f468f641d17 Mon Sep 17 00:00:00 2001
From: realcodywburns <cody.w.burns@gmail.com>
Date: Sat, 12 Jan 2019 21:20:13 -0600
Subject: [PATCH 2/2] Update process

---
 README.md | 38 ++++++++++++++++++++++++++++++--------
 1 file changed, 30 insertions(+), 8 deletions(-)

diff --git a/README.md b/README.md
index d17e1171..165eb3d6 100644
--- a/README.md
+++ b/README.md
@@ -2,17 +2,41 @@
 
 [![Join the chat at https://gitter.im/ethereumproject/ECIPs](https://badges.gitter.im/ethereumproject/ECIPs.svg)](https://gitter.im/ethereumproject/ECIPs?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
 
-# Current ECIPs
+
+# Getting started contributing
+The [ECIP sample](./ECIP-1.sample.md) is the best place to start. The sample was updated for Ethereum use by Martin Becze, it was predominantly derived from the Bitcoin improvement proposal based on the Python improvement proposal system. Fork the repository and add your ECIP to it, using the provided [ECIP markdown template](./ECIP-number.template.md). Submit by creating a Pull Request to the Ethereum Classic [ECIPs repository](https://github.com/ethereumclassic/ECIPs).
+
+# Contributing
+
+ 1. Review [ECIP-1](./ecip-1.sample.md).
+ 2. Fork the repository by clicking "Fork" in the top right.
+ 3. Add your ECIP to your fork of the repository. There is a [template ECIP here](ecip-number.template.md).
+ 4. Submit a Pull Request to Ethereum Classic's [ECIPs repository](https://github.com/ethereumclassic/ECIPs).
+
+Your first PR should be a first draft of the final ECIP. It must meet the formatting criteria enforced by the build (largely, correct metadata in the header). An editor will manually review the first PR for a new ECIP and assign it a number before merging it. Make sure you include a `discussions-to` header with the URL to a discussion forum or open GitHub issue where people can discuss the ECIP as a whole.
+
+If your ECIP requires images, the image files should be included in a subdirectory of the `assets` folder for that ECIP as follow: `assets/eip-X` (for ecip **X**). When linking to an image in the ECIP, use relative links such as `../assets/ecip-X/image.png`.
+
+When you believe your ECIP is mature and ready to progress past the draft phase, you should do one of two things:
+
+ - **For a Standards Track ECIP of type Core**, ask to have your issue added to the agenda of an upcoming All Dev Team meeting, where it can be discussed for inclusion in a future hard fork. If implementers agree to include it, the ECIP editors will update the state of your ECIP to 'Accepted'.
+ - **For all other ECIPs**, open a PR changing the state of your ECIP to 'Final'. An editor will review your draft and ask if anyone objects to its being finalised. If the editor decides there is no rough consensus - for instance, because contributors point out significant issues with the ECIP - they may close the PR and request that you fix the issues in the draft before trying again.
+
+# ECIP Status Terms
+* **Draft** - an ECIP that is undergoing rapid iteration and changes
+* **Last Call** - an ECIP that is done with its initial iteration and ready for review by a wide audience
+* **Final (non-Core)** - an ECIP that has been in Last Call for at least 2 weeks and any technical changes that were requested have been addressed by the author.
+* **Final (Core)** - an ECIP that the dev teams have decide to implement and release in a future hard fork or has already been released in a hard fork
+* **Accepted** - a core ECIP that has been in Last Call for at least 2 weeks and any technical changes that were requested have been addressed by the author
+
+* **Deferred** - an ECIP that is not being considered for immediate adoption. May be reconsidered in the future for a subsequent hard fork.
+
+# Accepted ECIPs
 
 | Number        | Title        | Author | Type  | Layer        | Status / Discussion |
 | ------------- | ------------ | ------ | ----- | -------------| ------------------- |
 | [ECIP-1010](ECIPs/ECIP-1010.md) | Delay Difficulty Bomb Explosion | Igor Artamonov | Standard | Consensus (hard-fork) | [Accepted](https://github.com/ethereumproject/ECIPs/issues/4) |
-| [ECIP-1013](ECIPs/ECIP-1013.md) | ETC On-Chain Cryptographic Signing and Authentication Protocol | Cody W Burns | Standard | Meta | Draft |
 | [ECIP-1017](ECIPs/ECIP-1017.md) | Monetary Policy and Final Modification to the Ethereum Classic Emission Schedule | Matthew Mazur | Standard | Consensus (hard-fork) | Accepted |
-| [ECIP-1021](ECIPs/ECIP-1021.md) | ERC223 Token Standard | Dexaran | Standard | ERC | Draft |
-| [ECIP-1022](ECIPs/ECIP-1022.md) | Generalized Version Bits Voting for Consensus Soft and Hard Forks | Wei Tang | Standard | Informational | Draft |
-| [ECIP-1023](ECIPs/ECIP-1023.md) | Combined CarbonVote and MinerVote for Consensus Soft and Hard Forks | Wei Tang | Standard | Informational | Draft |
-| [ECIP-1030](ECIPs/ECIP-1030.md) | Defining the SYSTEM Transaction | Wei Tang | Standard | Meta | Draft |
 
 # EIPs that applies to Ethereum Classic network
 
@@ -45,6 +69,4 @@ The Ethereum Foundation raised money from the community to work towards the "mis
 
 Decentralized decision making is part of the in-depth security that protects the integrity of the Ethereum Classic blockchain. It is critical for keeping the promise of "applications that run exactly as programmed without any possibility of downtime, censorship, fraud or third party interference."
 
-# Getting started contributing
-The [ECIP sample](./ECIP-1.sample.md) is the best place to start. The sample was updated for Ethereum use by Martin Becze, it was predominantly derived from the Bitcoin improvement proposal based on the Python improvement proposal system. Fork the repository and add your ECIP to it, using the provided [ECIP markdown template](./ECIP-number.template.md). Submit by creating a Pull Request to the Ethereum Classic [ECIPs repository](https://github.com/ethereumclassic/ECIPs).
 
