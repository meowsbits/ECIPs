{
    "id": 478962696,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODk2MjY5Ng==",
    "url": "https://api.github.com/repos/ethereumclassic/ECIPs/pulls/comments/478962696",
    "pull_request_review_id": 477544083,
    "diff_hunk": "@@ -0,0 +1,282 @@\n+---\n+ecip: <ECIP number>\n+title: 51% Attack Resistance \n+lang: en\n+author: Dimitris Karakostas, Radek Tkaczyk, Romain Pellerin, Brian McKenna\n+discussions-to: https://github.com/ethereumclassic/ECIPs/issues/348 | https://github.com/input-output-hk/ECIPs/issues/1\n+status: Draft\n+type: Standards Track\n+category: Core\n+created: 2020-08-26\n+---\n+\n+### Abstract\n+\n+This document outlines a proposal for the implementation of a system to provide 51% attack resistance on the Ethereum Classic blockchain. It describes the high-level structure and general properties of such a system. IOHK has already researched and implemented the checkpointing protection on ETC, and has detailed specifications for each part of the system, as well as reference implementation, that can be found in [this repository](https://github.com/input-output-hk/checkpointing_code_plus_ecip).\n+\n+### Motivation\n+\n+Distributed ledgers based on the Proof-of-Work (PoW) paradigm are typically most vulnerable when mining participation is low. During these periods an attacker can mount devastating attacks, such as double spending or censorship of transactions [^CHECK]. We have seen recently that this is particularly relevant to ETC, as witnessed by the two attacks that took place in August 2020.\n+\n+Checkpointing is proposed as a mechanism to mitigate such 51% attacks. The core idea is to employ an external set of parties that securely run an assisting service which guarantees the ledger's properties and can be relied upon at times when the invested hashing power is low. Once hashing power reaches a level where an attack is no longer financially viable, the system can be discontinued.\n+\n+The future viability of ETC in its current, unsecured state is now in question. Implementing a fully tested Checkpointing solution, running the Ouroboros-BFT (OBFT) consensus protocol, would provide high assurance, with low performance requirements. It would also boost confidence in the network and provide the much needed stability required to take ETC to a level where 51% attacks are no longer feasible.\n+\n+### Specification\n+\n+The checkpointing authority monitors the growth of the chain and periodically issues checkpoints, which are points at which validations occur. As soon as it observes the first valid chain, which extends the latest checkpoint by `ùëò` blocks (for some constant value `ùëò`), the authority signs this chain‚Äôs last block and broadcasts this signature, thus producing a new checkpoint.\n+\n+From the user perspective, chain selection is augmented by enforcing a rule where a chain is valid only if it extends the latest checkpoint. In particular, when selecting a chain, honest use applies as follows:\n+\n+- first verifies that it contains the latest checkpoint; and\n+- then applies the longest-chain rule to all validly checkpointed candidates.\n+\n+Even an adversary controlling a majority of the mining power cannot revert the block history secured by the latest checkpoint, as an honest user will (eventually) reject any chain that does not extend this checkpoint.\n+\n+The checkpointing authority is distributed among a number `ùëõ` of nodes. These nodes run an internal Byzantine fault tolerant (BFT) consensus protocol, Ouroboros BFT [^OBFT], to coordinate the issuing of checkpoints.\n+\n+The checkpointing nodes use a multi-signature scheme to produce each checkpoint. A ùë°-out-of-ùëõ multi-signature scheme allows a set of ùëõ parties to collectively sign a message under the necessary condition that at least `ùë°` of the parties collaborate in order to sign this message. The checkpointing nodes issue their chosen checkpoints by creating respective multi-signature2s using their keys. Choosing ``ùë° > ùëõ ‚àí ùë°`` implies that correct (agreed-upon) checkpoints will be continuously produced, while the forgery of checkpoints is impossible assuming that a minority of the checkpointing nodes is corrupted.\n+\n+#### Checkpointing Service\n+\n+The federation needs to agree upon the block to be checkpointed. The proposed solution consist of two components:\n+\n+- a dedicated ETC node that will be used by the federation to monitor and retreive data.\n+- a checkpointing service server (the server) which allows federation nodes to reach an agreement.\n+\n+The server is based on Ouroboros BFT [^OBFT]. Ourobotos BFT is a blockchain-based Byzantine Fault Tolerant protocol, i.e. it‚Äôs resilient to `t < n / 3` faults, that aims to be simple without compromising security soundness. \n+\n+Simplicity is achieved by the fact participants just need to do two things: extend their blockchain and generate the next block, if they are eligible.\n+\n+The service should periodically execute the following process:\n+\n+1. Fetch the latest block candidate for checkpointing using `checkpointing_getLatestBlock` RPC call. This RPC method returns just the number and hash of the latest matching block, for which `block_number % checkpointing_interval == 0`\n+2. Cast a vote with a signature for this block. The vote is a transaction broadcasted in the OBFT network\n+3. Upon reaching consensus in the OBFT chain (a majority of votes for a given ETC block), a checkpoint with all matching signatures is sent to the associated ETC nodes, from where it is broadcasted to the entire network.\n+\n+#### Checkpointing Network Definition\n+\n+The method for selecting the checkpointing committee is a key element of this proposal and must be carefully analyzed and agreed by the ETC community members who have considered the governance implications. In fact, the original PoW consensus is augmented by a layer of security offered by a checkpointing network. This network can be either secured by a federation of ETC entities, by the dynamic selection of a random committee of ETC miners or by implementing a timestamping protocol on an external chain (BTC).\n+\n+These three options and how they can be implemented are outlined as part  of this proposal:\n+\n+##### Option 1: Trusted network of federated ETC entities\n+\n+In this federated option, the checkpointing network is operated and secured by a committee of n members selected by the ETC community. This committee can be either:\n+\n+- founded by `k` entities and extended by a majority vote, `k < n`;\n+- extended to miners and/or developers and/or stakeholders;\n+- elected for a period of time `t`;\n+\n+We envisage that a multitude of selection criteria could be used to form the committee, but we advise the community to keep this mechanism as lean as possible in a _first implementation by defining a fixed group of federation members_. \n+\n+We understand that the aforementioned alternative might not be optimally flexible, so we are proposing an optional improvement that will allow checkpointing to potentially rotate the checkpointing federation. The specific implementation of this federated option will be provided as a smart contract that adheres to the following election mechanism:\n+\n+- `p` the duration of a voting epoch \n+- `a` voting epoch is comprised of three periods; pre-voting, voting, and tally, each lasting `p/3`\n+- pre-voting period starts;\n+- `C` candidates register with their respective public key;\n+- at the end of the pre-voting step if `C < n` the vote fails and go to 1;\n+- else the voting period starts;\n+- each stakeholder votes with his/her ETC stake for the candidate(s) of his/her choice, and stake is locked until the vote ends;\n+- voting period ends;\n+- tally period starts and calculates the list of entities which gathered the most stake (in case of equivalent stake lexical order of public key prevails), and will form the committee for a designated period of time;\n+- tally ends, list is confirmed;\n+- when `t - p` expires go to 1.\n+\n+Optionally, we can provide a privacy-enabled voting mechanism to ensure that votes will remain anonymous. Depending on the complexity this might be delivered as a second-layer solution. \n+\n+We suggest the following configuration: `p=30 (days)`, `n=100`  and  `t=180 (days)`. \n+\n+This list can be publicly accessed through a getter smart-contract.\n+\n+This method can then be called by the nodes that participate in the checkpointing network, and only the nodes listed can issue checkpoints themselves.\n+\n+- Pros:\n+    - Community-driven and on-chain selection of com mittee\n+    - Reliability of the n participants\n+\n+- Cons:\n+    - A very wealthy attacker can register multiple public keys and vote for himself to obtain a majority of checkpoint signatures \n+    - This is an example of how one could implement a voting scheme, however this scheme starts to resemble Proof of Stake and it may be worthwhile considering hybrid consensus if this scheme is deemed favourable by the community\n+\n+\n+##### Option 2: Dynamic network of ETC miners\n+\n+In this dynamic and random selection option, the checkpointing network is operated and secured by a committee of k miners who are randomly selected at every epoch through the blockchain data structure and history. The parameters for this random selection can be either :\n+- based on the lexical distance of the miner‚Äôs public key with the last block hash;\n+- within a window of time determining a subset of miners;\n+- within a set of NiPoPoWs [^NIPOPOW] graphs;\n+\n+We envisage that a multitude of randomized selection algorithms could be used, but we advise the community to select the solution that offers the best resistance to attacks.\n+\n+The specific implementation of this dynamic and random selection option will be provided as a consensus algorithm used in the checkpointing blockchain that actively monitors the ETC blockchain. The following is a draft proposal for the committee selection algorithm that we consider offers  sufficient protection against long range attacks:\n+- `e` an epoch of a duration t in which a new list of at least `n` miners is determined;\n+- `p` the maximum processing time for this algorithm;\n+- `w` a sliding window of `k blocks` from the latest block of the latest epoch `window + window_min` (or `last block - window_min` at initialization), `k` calculated based on the difficulty  and  `k > window_min`;\n+- calculate `npp(k)` the subset of `k` latest NiPoPow graphs;\n+- calculate `l(npp(k))`the list of miners‚Äô public keys that have contributed to mine the blocks contained by `npp(k)`removing duplicates (set);\n+- if `length(l(npp(k))) < n` go to 2.;\n+- else the list is determined \n+- when `t - p` expires go to 1.\n+\n+- Pros\n+    - Checkpointing network is secured by miners\n+    - On-chain selection of committee\n+    - Decreased risk of collusion within the committee\n+- Cons\n+    - Sensitive to long range attacks \n+    - Draft solution and the secure algorithm, or equivalent, needs to be formalised\n+    - It may not be possible to prove a satisfactory level of security with this scheme, also to make such a scheme secure will likely increase implementation complexity\n+\n+##### Option 3: Auxiliary Security from an External Blockchain\n+\n+This option relies on utilizing an external distributed ledger as a timestamping service. We believe that Bitcoin, being the most used and, arguably, most secure existing distributed ledger, can serve as an anchor of security for ETC, in the manner described below.\n+\n+The timestamping protocol, which can be used to secure ETC, is parameterized with:\n+- `kc`: the checkpointing interval. Note that kc needs to be large enough, such that a timestamp has enough time to become stable on Bitcoin; in practice, it should correspond to, at the very least, 60 minutes.\n+- `g`: the ETC block number, which marks the beginning of the timestamped period.\n+\n+Mining in ETC under timestamping works as follows. When a miner tries to produce a new block, with block number `j`: \n+\n+- If `j = g + i*kc` for some integer `i`, i.e. every kc blocks, they construct a special checkpointed block as follows:\n+    - They retrieve from Bitcoin the timestamp of the most recently checkpointed ETC block; in general, this will be the block with number `g + (i - 1)*kc`. The timestamp is the position in the Bitcoin ledger of the oldest transaction which contains part of the header of this checkpointed ETC block.\n+    - They insert to the new ETC block the timestamp retrieved in step 1, in a special header field.\n+    - After creating the new ETC block, they timestamp its headers on Bitcoin, via a series of `OP_RETURN` transactions; the first such transaction to be published on Bitcoin will be the new block's timestamp.\n+- If `j ‚â† g + i*kc` for any integer `i`, then the miner creates a standard ETC block as usual.\n+\n+When choosing between two ETC chains, `C1` and `C2`, intuitively, an ETC node prioritizes timestamps over PoW. Specifically, between two competing blocks, it always chooses the one with the oldest timestamp, i.e. the one that was created first. If neither block and they both stem from the same timestamped block, then PoW is enforced. Specifically, a node does as follows:\n+- It finds the common ancestor block BC of the two chains\n+- In each chain, it finds the first block  Bt1`, `Bt2` after `BC` which has been timestamped on Bitcoin\n+- If `timestamp(Bt1) < timestamp(Bt2)`, i.e. if Bt1 was timestamped before `Bt2`, then the miner picks `C1`; otherwise they pick `C2`\n+- If `BC` is the latest timestamped block on both chains, then the standard maxvalid rule applies\n+\n+Note 1: In practice, an ETC miner can choose on which chain to mine before a timestamp becomes stable in the Bitcoin ledger. Specifically, they may assume that the Bitcoin miners follow a first-come-first-in-the-block rule, such that the first timestamping transaction that the ETC miner observes on the Bitcoin network will eventually be the correct one.\n+\n+Note 2: The above proposal applies on any alternative distributed ledger that enables publishing arbitrary data, such as Litecoin or Bitcoin Cash (on the PoW side) or Cardano (on the PoS side).\n+\n+High Level Requirements\n+\n+- ETC miners need to run a full Bitcoin node to retrieve and verify timestamps\n+- ETC miners need to own some Bitcoins to create timestamping transactions; on September 2019, this cost was $3.6 per block, see [^CHECK]\n+- A soft fork will be required to add the special header field (see mining step (b)), which is needed to ensure liveness\n+\n+- Pros\n+    - Supplemental security can be provided by other blockchains (Bitcoin, Ethereum, Polkadot, Cardano etc.) \n+    - No need to elect or agree upon a (semi)centralized committee\n+    - Security is ensured in the most decentralized way possible; in order to break the security of checkpoints, an attacker needs to break Bitcoin's security\n+    - The design ensures liveness via the unpredictable timestamp (introduced in mining step b), which could not be achieved e.g. if simply a hash of the ETC chain were published on Bitcoin\n+\n+- Cons\n+    - ETC miners need to run a Bitcoin full node and own some bitcoins, in order to retrieve and publish timestamping transactions\n+    - Bitcoin fees may be non-trivial\n+    - Bitcoin block latency (10 minutes) may result in delays or misplaced mining work, in case timestamping transactions are published in a Bitcoin block out-of-order, i.e. in a different order from the order of creation\n+\n+### Implementation\n+\n+The following section refers to the _Option 1 with fixed commite members_\n+\n+#### Data Structures\n+\n+A checkpoint is another block in the chain. To distinguish it from regular blocks we need an extra field in the header called checkpoint. To simplify implementation all other header fields remain the same. What follow is recipe to build checkpoint block:\n+\n+```\n+parentHash = <same as regular block>\n+beneficiary = address: 0x0\n+difficulty = <same as parent>\n+number = <same as regular block>\n+gasLimit = <same as parent>\n+timestamp = parent.timestamp + 1\n+extraData = <empty>\n+stateRoot = <same as parent>\n+transactionsRoot = <empty MPT>\n+receiptsRoot = <empty MPT>\n+logsBloom = <empty bloom filter>\n+checkpoint = <list of signatures or empty for regular block>\n+gasUsed = 0\n+mixHash = <empty>\n+nonce = <empty>\n+```\n+\n+where the signature follows the same ECDSA scheme as transaction signatures and consists of:\n+\n+```\n+R = <R component of ECDSA signature: 32 bytes>\n+S = <S component of ECDSA signature: 32 bytes>\n+V = <offsetted recovery id, 27 or 28: 1 byte>\n+```\n+\n+Notes:\n+- there is no block reward for a checkpoint block\n+- timestamp should be predetermined so that all federation nodes construct exactly the same header\n+\n+Validation of checkpoint upon import should check that all header values match the recipe specified above. It should also validate that the checkpoint block does not contain any signatures.\n+\n+#### Consensus changes\n+\n+In order to facilitate checkpointing the following consensus changes need to be made:\n+\n+1. Each node in the network should be configured with a list of ECDSA public keys of the Checkpointing Federation\n+2. Upon importing a checkpoint block a node should verify the signatures conveyed in the checkpoint field against the parentHash of the block. The recovered keys must match the keys in 1. and each signature must come from a unique signer (note that checking signature non-equality is not enough)\n+3. Once a checkpoint has been imported it becomes stable in the chain. It can never be rolled back.\n+\n+#### JSON-RPC Additions\n+\n+An ETC node that is part of the Checkpointing Federation must implement these RPC methods to communicate with an OBFT node:\n+\n+- **`checkpointing_getLatestBlock`**\n+\n+Returns the hash and number for the latest block that matches the given checkpointing interval\n+\n+Parameters:\n+\n+- `QUANTITY` - integer checkpointing interval\n+\n+Example:\n+\n+```\n+// request\n+curl -X POST --data '{\"jsonrpc\":\"2.0\", \"method\":\"checkpointing_getLatestBlock\", \"params\":[4], \"id\":1}\n+\n+// result\n+{\n+  \"jsonrpc\": \"2.0\",\n+  \"result\": {\n+    \"hash\":     \"0x6cb6eb11c3f12689171585fde5107110fc846098ad02e323ff08eec1f9474f74\",\n+    \"number\": 12 // 12 will be returned when the current best  \n+                 // block number is on of 12, 13, 14, 15\n+  },\n+  \"id\": 1\n+}\n+```\n+\n+- **`checkpointing_pushCheckpoint`**\n+\n+Used to push checkpoint information from the OBFT node to the associated ETC node\n+\n+Parameters:\n+\n+- `DATA` - hash of the checkpointed block, 32 bytes\n+- `Array of DATA` - a list ECDSA signatures encoded in 65-byte uncompressed format\n+\n+Example:\n+```\n+// request\n+curl -X POST --data '{\"jsonrpc\":\"2.0\", \"method\":\"checkpointing_pushCheckpoint\", \"params\":[‚Äú0x6cb6eb11c3f12689171585fde5107110fc846098ad02e323ff08eec1f9474f74‚Äù, [\"87fe715bfff7d6143f0ffd5662a54baa2ada865a0c83b248e67689100b0258356d155823b049815faca88cd2ea7c99a6fa601bdca787624272f752f35656a64a1c\", \"ec8b3662520174d4be70c4e91bcd7f156b21de54e60b2ed8019d8608dc0199cb231067508eca311b652b52328df34a74f720d4b08423eb4b528fdf1eece1478d1c\", \"2c53c2a4e1b4a3fb20d6f7e42fd4a72a703efededb66ca75c15495ccdc5eacdc1cd3b803b9149a92161e8373da035849272db7c299b56676649d31344e1446211c\" ]], \"id\":1}\n+\n+// result\n+{\n+  \"jsonrpc\": \"2.0\",\n+  \"result\": true,\n+  \"id\": 1\n+}\n+```\n+",
    "path": "_specs/51_attack_resistance.md",
    "position": 274,
    "original_position": 274,
    "commit_id": "51cd72ea08557a38876e80fbc7471967a8a27a42",
    "user": {
      "login": "q9f",
      "id": 58883403,
      "node_id": "MDQ6VXNlcjU4ODgzNDAz",
      "avatar_url": "https://avatars2.githubusercontent.com/u/58883403?u=72563674ea84909432bf249ab92fb936dffa313d&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/q9f",
      "html_url": "https://github.com/q9f",
      "followers_url": "https://api.github.com/users/q9f/followers",
      "following_url": "https://api.github.com/users/q9f/following{/other_user}",
      "gists_url": "https://api.github.com/users/q9f/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/q9f/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/q9f/subscriptions",
      "organizations_url": "https://api.github.com/users/q9f/orgs",
      "repos_url": "https://api.github.com/users/q9f/repos",
      "events_url": "https://api.github.com/users/q9f/events{/privacy}",
      "received_events_url": "https://api.github.com/users/q9f/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This proposal lacks a license, please add one or waive rights via CC-0.",
    "created_at": "2020-08-28T08:52:33Z",
    "updated_at": "2020-08-28T09:57:37Z",
    "html_url": "https://github.com/ethereumclassic/ECIPs/pull/347#discussion_r478962696",
    "pull_request_url": "https://api.github.com/repos/ethereumclassic/ECIPs/pulls/347",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/ethereumclassic/ECIPs/pulls/comments/478962696"
      },
      "html": {
        "href": "https://github.com/ethereumclassic/ECIPs/pull/347#discussion_r478962696"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/ethereumclassic/ECIPs/pulls/347"
      }
    },
    "original_commit_id": "51cd72ea08557a38876e80fbc7471967a8a27a42"
  }