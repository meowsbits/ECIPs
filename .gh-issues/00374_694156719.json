{
    "url": "https://api.github.com/repos/ethereumclassic/ECIPs/issues/comments/694156719",
    "html_url": "https://github.com/ethereumclassic/ECIPs/issues/374#issuecomment-694156719",
    "issue_url": "https://api.github.com/repos/ethereumclassic/ECIPs/issues/374",
    "id": 694156719,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5NDE1NjcxOQ==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-09-17T10:58:18Z",
    "updated_at": "2020-09-17T10:58:18Z",
    "author_association": "CONTRIBUTOR",
    "body": "This all seems reasonable!\r\n\r\n> There is no Edge-of-Eternity attack vector (no vulnerable focal points for an attacker to target).\r\n\r\nNot sure I understand this. I assume \"edge of eternity attack\" is an established term in ETC land discourse that I'm just not familiar with? My guess is that this means something like \"there's no fixed ratio of hashpower that an attacker can split between two chains to cause a permanent split between them\", which seems true, though with the caveat that doesn't rule out the possibility of a variable-hashpower balancing strategy....\r\n\r\nHaving a cap at 32x or some value in that ballpark seems totally reasonable; you're right that there's no need to have the ratio keep increasing forever.\r\n\r\nPersonally I find the notion of using floats in the consensus-layer spec definition to be quite :vomiting_face: :vomiting_face: :vomiting_face: ; you're basically importing the entire [IEEE 754 floating point spec](https://en.wikipedia.org/wiki/IEEE_754) into the de-facto consensus rules (and in addition the precise calculation of the sine in floating point... are you _sure_ there aren't subtle differences between languages?). Ethereum EIPs and eth2 EIPs all stick to integers (and eth2 goes even further, sticking exclusively to positive integers!).\r\n\r\nThe eth2 way of doing this would be an approximation like:\r\n\r\n```\r\nCURVE_FUNCTION_DENOMINATOR = 128\r\n\r\ndef get_curve_function_numerator(time_delta: int) -> int:\r\n    xcap = 25132 # = floor(8000*pi)\r\n    ampl = 15\r\n    height = CURVE_FUNCTION_DENOMINATOR * (ampl * 2)\r\n    if x > xcap:\r\n        x = xcap\r\n    # The sine approximator `y = 2*x**3 - 3*x**2` rescaled to the desired height and width\r\n    return CURVE_FUNCTION_DENOMINATOR + (3 * x**2 - 2 * x**3 // xcap) * height // xcap ** 2\r\n```\r\nThe `if tdRatio < antiGravity` check would then be `if proposed_subchain_td * CURVE_FUNCTION_DENOMINATOR <  get_curve_function_numerator(proposed.Time - commonAncestor.Time) * local_subchain_id`.\r\n\r\nHere's a comparison chart of the sinusoidal function versus this one: https://imgur.com/XNXGwZb\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereumclassic/ECIPs/issues/comments/694156719/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }