{
    "url": "https://api.github.com/repos/ethereumclassic/ECIPs/issues/comments/702353926",
    "html_url": "https://github.com/ethereumclassic/ECIPs/issues/327#issuecomment-702353926",
    "issue_url": "https://api.github.com/repos/ethereumclassic/ECIPs/issues/327",
    "id": 702353926,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwMjM1MzkyNg==",
    "user": {
      "login": "wpwrak",
      "id": 1292352,
      "node_id": "MDQ6VXNlcjEyOTIzNTI=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1292352?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wpwrak",
      "html_url": "https://github.com/wpwrak",
      "followers_url": "https://api.github.com/users/wpwrak/followers",
      "following_url": "https://api.github.com/users/wpwrak/following{/other_user}",
      "gists_url": "https://api.github.com/users/wpwrak/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wpwrak/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wpwrak/subscriptions",
      "organizations_url": "https://api.github.com/users/wpwrak/orgs",
      "repos_url": "https://api.github.com/users/wpwrak/repos",
      "events_url": "https://api.github.com/users/wpwrak/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wpwrak/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-01T19:36:24Z",
    "updated_at": "2020-10-01T19:36:24Z",
    "author_association": "NONE",
    "body": "A formal specification would be 1) concise, 2) allow comparing its model against related specification, such as that of Ethash, 3) allow to precisely model the behaviour of the proposed change, and 4) allow verifying that implementations match the specification. Pirlguard comes with a) very high-level descriptions of the general idea, and b) a patch to an existing client.\r\n\r\na) means that there is far too much room for interpretation, and all the elementary steps (e.g., what information is present at what time, both in terms of state and in terms of data passed between clients, how exactly it is to be used, including how it affects state) are not clearly defined. b) in a way provides that detail, but puts it in the context of a complex implementation. So in order to understand what exactly that patch is doing, you need to i) be very familiar with the implementation of go-callisto, and ii) know the Go language. Worse, the pointer to the code is not even versioned, so you'd have to consider all past and future changes to any of the code not only in the Pirlguard extension but to go-callisto as a whole.\r\n\r\nBasing specifications on implementations is inherently dangerous. Even if the implementation tries to be concise, you can quickly end up with code that doesn't work or that does not behave the way it was intended. This is especially true if you're using one of the \"new\" languages, that still change fairly frequently. As an example, consider the Ethash reference in Python, at\r\nhttps://eth.wiki/en/concepts/ethash/ethash\r\nIt looks nice and concise, but if you try to run it, you'll find that it doesn't work, and you may find that it produces results that differ from what real Ethash does. For a runnable implementation that does produce correct results, see\r\nhttps://github.com/LinzhiChips/ethash-ecip1043/blob/master/ethash.py\r\n\r\ngo-callisto is a lot more code, so imagine all the things that you may have to consider there. Not because they would affect what Pirlguard does, but because you can't be sure that they don't unless you have checked them. That's why a specification should be concise and self-reliant. Also, for analysis, you usually want to make simulations. It's usually not too hard to make a model from a good specification, but it's very hard to turn some big implementation into a simulation. (Been there, done that, but while it was fun at the time, I would recommend putting the bar a little lower: http://umlsim.sourceforge.net/)\r\n\r\nSo, to summarize, the high-level description, a), fails to meet requirements 2, 3, and 4. The code b) fails to meet 1, 2, and 4 (with the exception of the implementation being go-callisto, or very similar to it), and makes 3 too difficult to be of practical use.\r\n\r\nE.g., a good specification would first define the local state of the client, e.g., how the relevant part of the chain  is represented there. That's also an opportunity to define all the terminology and concepts that will be used, such as head(s), distances, and so on. Then it would define the current operation of incorporating new blocks obtained from a peer, in the terms of this specification, and a low level of abstraction. Now you have a basis for presenting the modification: define any state that gets added (if needed), then define what incorporation of new blocks looks like then.\r\n\r\nWith such a specification, one could immediately analyze whether the algorithm is sensitive to the timing or partitioning of  new blocks presented, whether state is affected by client resets, under what conditions clients may diverge for an undesirably long time, and so on.\r\n\r\nIf all that gets too long, you can also make a more compact specification that leaves our the underlying model, and reference a more detailed version. At least back when I was working with IETF specifications, that was common practice: the RFC stated the goals and provided the (patch-sized) core bits of the protocol/algorithm/etc., and then there were one or more papers with the underlying details and further analysis.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereumclassic/ECIPs/issues/comments/702353926/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }