{
    "url": "https://api.github.com/repos/ethereumclassic/ECIPs/issues/comments/674803624",
    "html_url": "https://github.com/ethereumclassic/ECIPs/issues/327#issuecomment-674803624",
    "issue_url": "https://api.github.com/repos/ethereumclassic/ECIPs/issues/327",
    "id": 674803624,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3NDgwMzYyNA==",
    "user": {
      "login": "Dexaran",
      "id": 26142412,
      "node_id": "MDQ6VXNlcjI2MTQyNDEy",
      "avatar_url": "https://avatars1.githubusercontent.com/u/26142412?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Dexaran",
      "html_url": "https://github.com/Dexaran",
      "followers_url": "https://api.github.com/users/Dexaran/followers",
      "following_url": "https://api.github.com/users/Dexaran/following{/other_user}",
      "gists_url": "https://api.github.com/users/Dexaran/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Dexaran/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Dexaran/subscriptions",
      "organizations_url": "https://api.github.com/users/Dexaran/orgs",
      "repos_url": "https://api.github.com/users/Dexaran/repos",
      "events_url": "https://api.github.com/users/Dexaran/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Dexaran/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-08-17T10:36:29Z",
    "updated_at": "2020-08-17T11:21:14Z",
    "author_association": "MEMBER",
    "body": "@phyro for this example let's define `chain_A(n)` and `chain_B(n)` where `n` is the number of a block. `A(n)` is `n`th block the the chain A. `chain_A` is the mainnet. We assume `PenaltyCheckLength == 60` as you have proposed while in practice I would suggest 12 or 20.\r\n \r\n>From my understanding, It can after the blocks have been reorged.\r\n\r\nYes - the attacker can add some blocks after the chain is already reorged. However it is not possible that the attacker will generate a relatively large number of blocks.\r\n\r\nI.e. when the mainnet is at block `A(n)` the attacker can generate block `B(n+1)`. Once the mainnet is at block `A(n+60)` the attacker could generate a number of blocks at `chain_B`. Say the attacker has `B(n+67)` or `B(n+70)` if he got very lucky. The difficulty adjustment would not allow the attacker to generate significant amount of blocks within this short time window between mainnet blocks `A(n)` and `A(n+60)`.\r\n\r\nThe attacker can only propagate as much blocks as he have generated within this time window as if he would be too late to propagate his block to the network at a moment of `A(n+60)` the attack will completely fail since `A(n+61)` is too late already.\r\n\r\n>Yes, but this problem can be bypassed if you just mine 80 blocks and then you have 20 windows from 60 to 80 you can try to hit.\r\n\r\n**This should not be like this.**\r\n\r\nSay the attacker have splitted off at block `A(n)` which means that his chain includes blocks:\r\n\r\n```\r\n A(n), B(n+1), B(n+2) ... B(n+60), B(n+61), ... B(n+80).\r\n```\r\n\r\nThis is really unlikely and assumes that the attacker has very harsh hashrate advantage if he was capable of generating that much blocks.\r\n\r\nThe mainnet chain includes blocks:\r\n\r\n```\r\n A(n), A(n+1), A(n+2) ... A(n+59).\r\n```\r\n\r\nAt the point of time the block A(n+59) is mined the attacker is **PREPARING and waiting for the block A(n+60) to be mined**.\r\n\r\nOnce the block A(n+60) is mined and propagated to the network the mainnet nodes start syncing it. At that moment the attacker must propagate block B(n+60). This is worth to note that one of the blocks A(n+60) and B(n+60) is better than the other so those nodes who have access to both blocks would pick one of them and **it is deterministic which decision is correct at this block height.**\r\n\r\nThe attacker then must propagate block B(n+61) to the nodes who have adopted block B(n+60) and cause them to refuse syncing with chain A.\r\n\r\nIf the attacker has failed to do so at block A(n+60) then at block A(n+61) he can do nothing already. The window between B(n+60) and B(n+80) does not grant any advantage to the attacker because those nodes who will make a decision regarding resyncing are at `chain_A` and they don't care about how longer the `chain_B` is once it suggests to rewrite more than 60 blocks.\r\n\r\nIn order to make your scenario with time window possible the attacker should have developed another `chain_C` starting at block `A(n+1)` so that the alternative chain C would include blocks\r\n\r\n```\r\nA(n), A(n+1), C(n+2), C(n+3) ... C(n+61)\r\n\r\n```\r\n\r\nThe attacker would have another one attempt to cause the network split at block A(n+61) / C(n+61) but if he fails to do so then the attack will also fail without any new time windows.\r\n\r\n>You can actually be smarter than I described. Mine 59 blocks and then split them. This way you can create K split by adding just a few blocks to each chain that shares most of the blocks.\r\n\r\nDeveloping a chain and causing a split (which is a hard task and dependant on luck already which means that it is very costly in practice) is not enough. The attacker must maintain the network for long time which requires him to pay for hashrate at that chain. Otherwise the nodes would sync to the main branch again eventually.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereumclassic/ECIPs/issues/comments/674803624/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 1,
      "eyes": 0
    },
    "performed_via_github_app": null
  }